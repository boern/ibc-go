// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/lightclients/grandpa/v1/grandpa.proto

package types

import (
	fmt "fmt"
	types "github.com/cosmos/ibc-go/v6/modules/core/02-client/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ClientState from Beefy tracks the current validator set, latest height,
// and a possible frozen height.
type ClientState struct {
	// 0: subchain
	// 1: parachain
	ChainType uint32 `protobuf:"varint,1,opt,name=chain_type,json=chainType,proto3" json:"chain_type,omitempty"`
	// chain_id string type, eg: ibc-1
	ChainId string `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// parachain id is uint type
	ParachainId uint32 `protobuf:"varint,3,opt,name=parachain_id,json=parachainId,proto3" json:"parachain_id,omitempty"`
	// block number that the beefy protocol was activated on the relay chain.
	// This should be the first block in the merkle-mountain-range tree.
	BeefyActivationHeight uint32 `protobuf:"varint,4,opt,name=beefy_activation_height,json=beefyActivationHeight,proto3" json:"beefy_activation_height,omitempty"`
	// the latest mmr_root_hash height
	LatestBeefyHeight types.Height `protobuf:"bytes,5,opt,name=latest_beefy_height,json=latestBeefyHeight,proto3" json:"latest_beefy_height"`
	// Latest mmr root hash
	MmrRootHash []byte `protobuf:"bytes,6,opt,name=mmr_root_hash,json=mmrRootHash,proto3" json:"mmr_root_hash,omitempty"`
	// latest subchain or parachain height
	LatestChainHeight types.Height `protobuf:"bytes,7,opt,name=latest_chain_height,json=latestChainHeight,proto3" json:"latest_chain_height"`
	// Block height when the client was frozen due to a misbehaviour
	FrozenHeight types.Height `protobuf:"bytes,8,opt,name=frozen_height,json=frozenHeight,proto3" json:"frozen_height"`
	// authorities for the current round
	AuthoritySet BeefyAuthoritySet `protobuf:"bytes,9,opt,name=authority_set,json=authoritySet,proto3" json:"authority_set"`
	// authorities for the next round
	NextAuthoritySet BeefyAuthoritySet `protobuf:"bytes,10,opt,name=next_authority_set,json=nextAuthoritySet,proto3" json:"next_authority_set"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{0}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

// Beefy Authority Info
type BeefyAuthoritySet struct {
	// Id of the authority set, it should be strictly increasing
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Number of validators in the set.
	Len uint32 `protobuf:"varint,2,opt,name=len,proto3" json:"len,omitempty"`
	// Merkle Root Hash build from BEEFY uncompressed AuthorityIds.
	Root []byte `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
}

func (m *BeefyAuthoritySet) Reset()         { *m = BeefyAuthoritySet{} }
func (m *BeefyAuthoritySet) String() string { return proto.CompactTextString(m) }
func (*BeefyAuthoritySet) ProtoMessage()    {}
func (*BeefyAuthoritySet) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{1}
}
func (m *BeefyAuthoritySet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeefyAuthoritySet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeefyAuthoritySet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeefyAuthoritySet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeefyAuthoritySet.Merge(m, src)
}
func (m *BeefyAuthoritySet) XXX_Size() int {
	return m.Size()
}
func (m *BeefyAuthoritySet) XXX_DiscardUnknown() {
	xxx_messageInfo_BeefyAuthoritySet.DiscardUnknown(m)
}

var xxx_messageInfo_BeefyAuthoritySet proto.InternalMessageInfo

// Actual payload items
type PayloadItem struct {
	// 2-byte payload id
	Id []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// arbitrary length payload data., eg mmr_root_hash
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *PayloadItem) Reset()         { *m = PayloadItem{} }
func (m *PayloadItem) String() string { return proto.CompactTextString(m) }
func (*PayloadItem) ProtoMessage()    {}
func (*PayloadItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{2}
}
func (m *PayloadItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayloadItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayloadItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayloadItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadItem.Merge(m, src)
}
func (m *PayloadItem) XXX_Size() int {
	return m.Size()
}
func (m *PayloadItem) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadItem.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadItem proto.InternalMessageInfo

func (m *PayloadItem) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *PayloadItem) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Commitment message signed by beefy validators
type Commitment struct {
	// array of payload items signed by Beefy validators
	Payloads []PayloadItem `protobuf:"bytes,1,rep,name=payloads,proto3" json:"payloads"`
	// block number for this commitment
	BlockNumber uint32 `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	// validator set that signed this commitment
	ValidatorSetId uint64 `protobuf:"varint,3,opt,name=validator_set_id,json=validatorSetId,proto3" json:"validator_set_id,omitempty"`
}

func (m *Commitment) Reset()         { *m = Commitment{} }
func (m *Commitment) String() string { return proto.CompactTextString(m) }
func (*Commitment) ProtoMessage()    {}
func (*Commitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{3}
}
func (m *Commitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commitment.Merge(m, src)
}
func (m *Commitment) XXX_Size() int {
	return m.Size()
}
func (m *Commitment) XXX_DiscardUnknown() {
	xxx_messageInfo_Commitment.DiscardUnknown(m)
}

var xxx_messageInfo_Commitment proto.InternalMessageInfo

// Signature with it`s index in merkle tree
type Signature struct {
	// signature leaf index in the merkle tree.
	Index uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// signature bytes
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{4}
}
func (m *Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return m.Size()
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

// signed commitment data
type SignedCommitment struct {
	// commitment data being signed
	Commitment Commitment `protobuf:"bytes,1,opt,name=commitment,proto3" json:"commitment"`
	// all the signatures
	Signatures []Signature `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures"`
}

func (m *SignedCommitment) Reset()         { *m = SignedCommitment{} }
func (m *SignedCommitment) String() string { return proto.CompactTextString(m) }
func (*SignedCommitment) ProtoMessage()    {}
func (*SignedCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{5}
}
func (m *SignedCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedCommitment.Merge(m, src)
}
func (m *SignedCommitment) XXX_Size() int {
	return m.Size()
}
func (m *SignedCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_SignedCommitment proto.InternalMessageInfo

// mmr data
type BeefyMMR struct {
	// signed commitment data
	SignedCommitment SignedCommitment `protobuf:"bytes,1,opt,name=signed_commitment,json=signedCommitment,proto3" json:"signed_commitment"`
	// build merkle tree based on all the signature in signed commitment
	// and generate the signature proof
	SignatureProofs [][]byte `protobuf:"bytes,2,rep,name=signature_proofs,json=signatureProofs,proto3" json:"signature_proofs,omitempty"`
	// mmr proof
	MmrLeavesAndBatchProof MMRLeavesAndBatchProof `protobuf:"bytes,3,opt,name=mmr_leaves_and_batch_proof,json=mmrLeavesAndBatchProof,proto3" json:"mmr_leaves_and_batch_proof"`
	// size of the mmr for the given proof
	MmrSize uint64 `protobuf:"varint,4,opt,name=mmr_size,json=mmrSize,proto3" json:"mmr_size,omitempty"`
}

func (m *BeefyMMR) Reset()         { *m = BeefyMMR{} }
func (m *BeefyMMR) String() string { return proto.CompactTextString(m) }
func (*BeefyMMR) ProtoMessage()    {}
func (*BeefyMMR) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{6}
}
func (m *BeefyMMR) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeefyMMR) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeefyMMR.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeefyMMR) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeefyMMR.Merge(m, src)
}
func (m *BeefyMMR) XXX_Size() int {
	return m.Size()
}
func (m *BeefyMMR) XXX_DiscardUnknown() {
	xxx_messageInfo_BeefyMMR.DiscardUnknown(m)
}

var xxx_messageInfo_BeefyMMR proto.InternalMessageInfo

// mmr leaves and proofs
type MMRLeavesAndBatchProof struct {
	// mmr leaves
	Leaves []MMRLeaf `protobuf:"bytes,1,rep,name=leaves,proto3" json:"leaves"`
	// mmr batch proof
	MmrBatchProof MMRBatchProof `protobuf:"bytes,2,opt,name=mmr_batch_proof,json=mmrBatchProof,proto3" json:"mmr_batch_proof"`
}

func (m *MMRLeavesAndBatchProof) Reset()         { *m = MMRLeavesAndBatchProof{} }
func (m *MMRLeavesAndBatchProof) String() string { return proto.CompactTextString(m) }
func (*MMRLeavesAndBatchProof) ProtoMessage()    {}
func (*MMRLeavesAndBatchProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{7}
}
func (m *MMRLeavesAndBatchProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MMRLeavesAndBatchProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MMRLeavesAndBatchProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MMRLeavesAndBatchProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MMRLeavesAndBatchProof.Merge(m, src)
}
func (m *MMRLeavesAndBatchProof) XXX_Size() int {
	return m.Size()
}
func (m *MMRLeavesAndBatchProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MMRLeavesAndBatchProof.DiscardUnknown(m)
}

var xxx_messageInfo_MMRLeavesAndBatchProof proto.InternalMessageInfo

func (m *MMRLeavesAndBatchProof) GetLeaves() []MMRLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *MMRLeavesAndBatchProof) GetMmrBatchProof() MMRBatchProof {
	if m != nil {
		return m.MmrBatchProof
	}
	return MMRBatchProof{}
}

// MmrLeaf leaf data
type MMRLeaf struct {
	// leaf version
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// // parent block for this leaf
	// uint32 parent_number = 2;
	// // parent hash for this leaf
	// bytes parent_hash = 3;
	// parent number and hash
	ParentNumberAndHash ParentNumberAndHash `protobuf:"bytes,2,opt,name=parent_number_and_hash,json=parentNumberAndHash,proto3" json:"parent_number_and_hash"`
	// beefy next authority set.
	BeefyNextAuthoritySet BeefyAuthoritySet `protobuf:"bytes,3,opt,name=beefy_next_authority_set,json=beefyNextAuthoritySet,proto3" json:"beefy_next_authority_set"`
	// merkle root hash of parachain heads included in the leaf.
	ParachainHeads []byte `protobuf:"bytes,4,opt,name=parachain_heads,json=parachainHeads,proto3" json:"parachain_heads,omitempty"`
}

func (m *MMRLeaf) Reset()         { *m = MMRLeaf{} }
func (m *MMRLeaf) String() string { return proto.CompactTextString(m) }
func (*MMRLeaf) ProtoMessage()    {}
func (*MMRLeaf) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{8}
}
func (m *MMRLeaf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MMRLeaf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MMRLeaf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MMRLeaf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MMRLeaf.Merge(m, src)
}
func (m *MMRLeaf) XXX_Size() int {
	return m.Size()
}
func (m *MMRLeaf) XXX_DiscardUnknown() {
	xxx_messageInfo_MMRLeaf.DiscardUnknown(m)
}

var xxx_messageInfo_MMRLeaf proto.InternalMessageInfo

// parent number and hash
type ParentNumberAndHash struct {
	// parent block for this leaf
	ParentNumber uint32 `protobuf:"varint,1,opt,name=parent_number,json=parentNumber,proto3" json:"parent_number,omitempty"`
	// parent hash for this leaf
	ParentHash []byte `protobuf:"bytes,2,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
}

func (m *ParentNumberAndHash) Reset()         { *m = ParentNumberAndHash{} }
func (m *ParentNumberAndHash) String() string { return proto.CompactTextString(m) }
func (*ParentNumberAndHash) ProtoMessage()    {}
func (*ParentNumberAndHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{9}
}
func (m *ParentNumberAndHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParentNumberAndHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParentNumberAndHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParentNumberAndHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParentNumberAndHash.Merge(m, src)
}
func (m *ParentNumberAndHash) XXX_Size() int {
	return m.Size()
}
func (m *ParentNumberAndHash) XXX_DiscardUnknown() {
	xxx_messageInfo_ParentNumberAndHash.DiscardUnknown(m)
}

var xxx_messageInfo_ParentNumberAndHash proto.InternalMessageInfo

func (m *ParentNumberAndHash) GetParentNumber() uint32 {
	if m != nil {
		return m.ParentNumber
	}
	return 0
}

func (m *ParentNumberAndHash) GetParentHash() []byte {
	if m != nil {
		return m.ParentHash
	}
	return nil
}

// mmr batch proof
type MMRBatchProof struct {
	// The index of the leaf the proof is for.
	LeafIndexes []uint64 `protobuf:"varint,1,rep,packed,name=leaf_indexes,json=leafIndexes,proto3" json:"leaf_indexes,omitempty"`
	// Number of leaves in MMR, when the proof was generated.
	LeafCount uint64 `protobuf:"varint,2,opt,name=leaf_count,json=leafCount,proto3" json:"leaf_count,omitempty"`
	// Proof elements (hashes of siblings of inner nodes on the path to the leaf).
	Items [][]byte `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *MMRBatchProof) Reset()         { *m = MMRBatchProof{} }
func (m *MMRBatchProof) String() string { return proto.CompactTextString(m) }
func (*MMRBatchProof) ProtoMessage()    {}
func (*MMRBatchProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{10}
}
func (m *MMRBatchProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MMRBatchProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MMRBatchProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MMRBatchProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MMRBatchProof.Merge(m, src)
}
func (m *MMRBatchProof) XXX_Size() int {
	return m.Size()
}
func (m *MMRBatchProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MMRBatchProof.DiscardUnknown(m)
}

var xxx_messageInfo_MMRBatchProof proto.InternalMessageInfo

func (m *MMRBatchProof) GetLeafIndexes() []uint64 {
	if m != nil {
		return m.LeafIndexes
	}
	return nil
}

func (m *MMRBatchProof) GetLeafCount() uint64 {
	if m != nil {
		return m.LeafCount
	}
	return 0
}

func (m *MMRBatchProof) GetItems() [][]byte {
	if m != nil {
		return m.Items
	}
	return nil
}

// ConsensusState
type ConsensusState struct {
	// timestamp that corresponds to the block height in which the ConsensusState
	// was stored.
	Timestamp time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// parachain header.state_root that used to verify chain storage proof
	Root []byte `protobuf:"bytes,2,opt,name=root,proto3" json:"root,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{11}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

// subchain header
type SubchainHeader struct {
	// chain_id string type, eg: ibc-1,astar-1
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// block number(height)
	BlockNumber uint32 `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	// scale-encoded subchain header bytes
	BlockHeader []byte `protobuf:"bytes,3,opt,name=block_header,json=blockHeader,proto3" json:"block_header,omitempty"`
	// timestamp and proof
	Timestamp StateProof `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp"`
}

func (m *SubchainHeader) Reset()         { *m = SubchainHeader{} }
func (m *SubchainHeader) String() string { return proto.CompactTextString(m) }
func (*SubchainHeader) ProtoMessage()    {}
func (*SubchainHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{12}
}
func (m *SubchainHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubchainHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubchainHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubchainHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubchainHeader.Merge(m, src)
}
func (m *SubchainHeader) XXX_Size() int {
	return m.Size()
}
func (m *SubchainHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_SubchainHeader.DiscardUnknown(m)
}

var xxx_messageInfo_SubchainHeader proto.InternalMessageInfo

// subchain header
type SubchainHeaders struct {
	SubchainHeaders []SubchainHeader `protobuf:"bytes,1,rep,name=subchain_headers,json=subchainHeaders,proto3" json:"subchain_headers"`
}

func (m *SubchainHeaders) Reset()         { *m = SubchainHeaders{} }
func (m *SubchainHeaders) String() string { return proto.CompactTextString(m) }
func (*SubchainHeaders) ProtoMessage()    {}
func (*SubchainHeaders) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{13}
}
func (m *SubchainHeaders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubchainHeaders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubchainHeaders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubchainHeaders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubchainHeaders.Merge(m, src)
}
func (m *SubchainHeaders) XXX_Size() int {
	return m.Size()
}
func (m *SubchainHeaders) XXX_DiscardUnknown() {
	xxx_messageInfo_SubchainHeaders.DiscardUnknown(m)
}

var xxx_messageInfo_SubchainHeaders proto.InternalMessageInfo

// data needed to prove parachain header inclusion in mmr
type ParachainHeader struct {
	// chain_id string type, eg: ibc-1,astar-1
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// para id must be uint
	ParachainId uint32 `protobuf:"varint,2,opt,name=parachain_id,json=parachainId,proto3" json:"parachain_id,omitempty"`
	// This block number is relayer chain blocknumber that parachain header packed into relayer block
	RelayerChainNumber uint32 `protobuf:"varint,3,opt,name=relayer_chain_number,json=relayerChainNumber,proto3" json:"relayer_chain_number,omitempty"`
	// scale-encoded parachain header bytes
	BlockHeader []byte `protobuf:"bytes,4,opt,name=block_header,json=blockHeader,proto3" json:"block_header,omitempty"`
	// proofs for parachain header in the mmr_leaf.parachain_heads
	Proofs [][]byte `protobuf:"bytes,5,rep,name=proofs,proto3" json:"proofs,omitempty"`
	// merkle leaf index for parachain heads proof
	HeaderIndex uint32 `protobuf:"varint,6,opt,name=header_index,json=headerIndex,proto3" json:"header_index,omitempty"`
	// total number of para heads in parachain_heads_root
	HeaderCount uint32 `protobuf:"varint,7,opt,name=header_count,json=headerCount,proto3" json:"header_count,omitempty"`
	// timestamp and proof
	Timestamp StateProof `protobuf:"bytes,8,opt,name=timestamp,proto3" json:"timestamp"`
}

func (m *ParachainHeader) Reset()         { *m = ParachainHeader{} }
func (m *ParachainHeader) String() string { return proto.CompactTextString(m) }
func (*ParachainHeader) ProtoMessage()    {}
func (*ParachainHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{14}
}
func (m *ParachainHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParachainHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParachainHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParachainHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParachainHeader.Merge(m, src)
}
func (m *ParachainHeader) XXX_Size() int {
	return m.Size()
}
func (m *ParachainHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ParachainHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ParachainHeader proto.InternalMessageInfo

// parachain header array
type ParachainHeaders struct {
	ParachainHeaders []ParachainHeader `protobuf:"bytes,1,rep,name=parachain_headers,json=parachainHeaders,proto3" json:"parachain_headers"`
}

func (m *ParachainHeaders) Reset()         { *m = ParachainHeaders{} }
func (m *ParachainHeaders) String() string { return proto.CompactTextString(m) }
func (*ParachainHeaders) ProtoMessage()    {}
func (*ParachainHeaders) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{15}
}
func (m *ParachainHeaders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParachainHeaders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParachainHeaders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParachainHeaders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParachainHeaders.Merge(m, src)
}
func (m *ParachainHeaders) XXX_Size() int {
	return m.Size()
}
func (m *ParachainHeaders) XXX_DiscardUnknown() {
	xxx_messageInfo_ParachainHeaders.DiscardUnknown(m)
}

var xxx_messageInfo_ParachainHeaders proto.InternalMessageInfo

// state value and proof
type StateProof struct {
	// state key
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// the state value
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// these proof gets from parachain by rpc methord:state_getReadProof
	Proofs [][]byte `protobuf:"bytes,3,rep,name=proofs,proto3" json:"proofs,omitempty"`
}

func (m *StateProof) Reset()         { *m = StateProof{} }
func (m *StateProof) String() string { return proto.CompactTextString(m) }
func (*StateProof) ProtoMessage()    {}
func (*StateProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{16}
}
func (m *StateProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateProof.Merge(m, src)
}
func (m *StateProof) XXX_Size() int {
	return m.Size()
}
func (m *StateProof) XXX_DiscardUnknown() {
	xxx_messageInfo_StateProof.DiscardUnknown(m)
}

var xxx_messageInfo_StateProof proto.InternalMessageInfo

func (m *StateProof) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *StateProof) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *StateProof) GetProofs() [][]byte {
	if m != nil {
		return m.Proofs
	}
	return nil
}

// header wrapper
type Header struct {
	// the latest mmr data
	BeefyMmr BeefyMMR `protobuf:"bytes,1,opt,name=beefy_mmr,json=beefyMmr,proto3" json:"beefy_mmr"`
	// only one header
	//
	// Types that are valid to be assigned to Message:
	//	*Header_SubchainHeaders
	//	*Header_ParachainHeaders
	Message isHeader_Message `protobuf_oneof:"message"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{17}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

type isHeader_Message interface {
	isHeader_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Header_SubchainHeaders struct {
	SubchainHeaders *SubchainHeaders `protobuf:"bytes,2,opt,name=subchain_headers,json=subchainHeaders,proto3,oneof" json:"subchain_headers,omitempty"`
}
type Header_ParachainHeaders struct {
	ParachainHeaders *ParachainHeaders `protobuf:"bytes,3,opt,name=parachain_headers,json=parachainHeaders,proto3,oneof" json:"parachain_headers,omitempty"`
}

func (*Header_SubchainHeaders) isHeader_Message()  {}
func (*Header_ParachainHeaders) isHeader_Message() {}

func (m *Header) GetMessage() isHeader_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Header) GetBeefyMmr() BeefyMMR {
	if m != nil {
		return m.BeefyMmr
	}
	return BeefyMMR{}
}

func (m *Header) GetSubchainHeaders() *SubchainHeaders {
	if x, ok := m.GetMessage().(*Header_SubchainHeaders); ok {
		return x.SubchainHeaders
	}
	return nil
}

func (m *Header) GetParachainHeaders() *ParachainHeaders {
	if x, ok := m.GetMessage().(*Header_ParachainHeaders); ok {
		return x.ParachainHeaders
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Header) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Header_SubchainHeaders)(nil),
		(*Header_ParachainHeaders)(nil),
	}
}

// Misbehaviour is a wrapper over two conflicting Headers
// that implements Misbehaviour interface expected by ICS-02
type Misbehaviour struct {
	ClientId string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty" yaml:"client_id"`
	Header1  Header `protobuf:"bytes,2,opt,name=header_1,json=header1,proto3" json:"header_1" yaml:"header_1"`
	Header2  Header `protobuf:"bytes,3,opt,name=header_2,json=header2,proto3" json:"header_2" yaml:"header_2"`
}

func (m *Misbehaviour) Reset()         { *m = Misbehaviour{} }
func (m *Misbehaviour) String() string { return proto.CompactTextString(m) }
func (*Misbehaviour) ProtoMessage()    {}
func (*Misbehaviour) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{18}
}
func (m *Misbehaviour) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Misbehaviour) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Misbehaviour.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Misbehaviour) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Misbehaviour.Merge(m, src)
}
func (m *Misbehaviour) XXX_Size() int {
	return m.Size()
}
func (m *Misbehaviour) XXX_DiscardUnknown() {
	xxx_messageInfo_Misbehaviour.DiscardUnknown(m)
}

var xxx_messageInfo_Misbehaviour proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ClientState)(nil), "ibc.lightclients.grandpa.v1.ClientState")
	proto.RegisterType((*BeefyAuthoritySet)(nil), "ibc.lightclients.grandpa.v1.BeefyAuthoritySet")
	proto.RegisterType((*PayloadItem)(nil), "ibc.lightclients.grandpa.v1.PayloadItem")
	proto.RegisterType((*Commitment)(nil), "ibc.lightclients.grandpa.v1.Commitment")
	proto.RegisterType((*Signature)(nil), "ibc.lightclients.grandpa.v1.Signature")
	proto.RegisterType((*SignedCommitment)(nil), "ibc.lightclients.grandpa.v1.SignedCommitment")
	proto.RegisterType((*BeefyMMR)(nil), "ibc.lightclients.grandpa.v1.BeefyMMR")
	proto.RegisterType((*MMRLeavesAndBatchProof)(nil), "ibc.lightclients.grandpa.v1.MMRLeavesAndBatchProof")
	proto.RegisterType((*MMRLeaf)(nil), "ibc.lightclients.grandpa.v1.MMRLeaf")
	proto.RegisterType((*ParentNumberAndHash)(nil), "ibc.lightclients.grandpa.v1.ParentNumberAndHash")
	proto.RegisterType((*MMRBatchProof)(nil), "ibc.lightclients.grandpa.v1.MMRBatchProof")
	proto.RegisterType((*ConsensusState)(nil), "ibc.lightclients.grandpa.v1.ConsensusState")
	proto.RegisterType((*SubchainHeader)(nil), "ibc.lightclients.grandpa.v1.SubchainHeader")
	proto.RegisterType((*SubchainHeaders)(nil), "ibc.lightclients.grandpa.v1.SubchainHeaders")
	proto.RegisterType((*ParachainHeader)(nil), "ibc.lightclients.grandpa.v1.ParachainHeader")
	proto.RegisterType((*ParachainHeaders)(nil), "ibc.lightclients.grandpa.v1.ParachainHeaders")
	proto.RegisterType((*StateProof)(nil), "ibc.lightclients.grandpa.v1.StateProof")
	proto.RegisterType((*Header)(nil), "ibc.lightclients.grandpa.v1.Header")
	proto.RegisterType((*Misbehaviour)(nil), "ibc.lightclients.grandpa.v1.Misbehaviour")
}

func init() {
	proto.RegisterFile("ibc/lightclients/grandpa/v1/grandpa.proto", fileDescriptor_cd16ccf01137b53b)
}

var fileDescriptor_cd16ccf01137b53b = []byte{
	// 1463 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4f, 0x73, 0x1b, 0xc5,
	0x12, 0xf7, 0xca, 0x1b, 0x4b, 0x6a, 0x49, 0xb6, 0x3c, 0xf1, 0xf3, 0xd3, 0xf3, 0x03, 0xcb, 0x28,
	0x40, 0x1c, 0x88, 0xa5, 0x48, 0xa9, 0xca, 0x21, 0x37, 0xcb, 0x95, 0x2a, 0x1b, 0xe2, 0xe0, 0x5a,
	0xe7, 0x40, 0x20, 0x55, 0xcb, 0xac, 0x76, 0x2c, 0x6d, 0x65, 0x77, 0x47, 0xb5, 0x33, 0x52, 0x45,
	0xf9, 0x04, 0xdc, 0xc8, 0x89, 0x33, 0x77, 0xaa, 0xe0, 0x04, 0x9f, 0x80, 0x43, 0x8e, 0xb9, 0x50,
	0xc5, 0xc9, 0x50, 0xce, 0x37, 0xc8, 0x81, 0x33, 0x35, 0x7f, 0x76, 0xb5, 0xb2, 0x8c, 0xe4, 0x10,
	0x6e, 0x33, 0x3d, 0xf3, 0xfb, 0xf5, 0x9f, 0xe9, 0xee, 0xed, 0x85, 0x1b, 0x9e, 0xd3, 0x69, 0xf8,
	0x5e, 0xb7, 0xc7, 0x3b, 0xbe, 0x47, 0x42, 0xce, 0x1a, 0xdd, 0x08, 0x87, 0x6e, 0x1f, 0x37, 0x86,
	0xcd, 0x78, 0x59, 0xef, 0x47, 0x94, 0x53, 0xf4, 0x7f, 0xcf, 0xe9, 0xd4, 0xd3, 0x57, 0xeb, 0xf1,
	0xf9, 0xb0, 0xb9, 0x51, 0x15, 0x3c, 0x1d, 0x1a, 0x91, 0x86, 0x3a, 0x14, 0x70, 0xb5, 0x52, 0xe8,
	0x8d, 0x6a, 0x97, 0xd2, 0xae, 0x4f, 0x1a, 0x72, 0xe7, 0x0c, 0x4e, 0x1a, 0xdc, 0x0b, 0x08, 0xe3,
	0x38, 0xe8, 0xeb, 0x0b, 0x6b, 0x5d, 0xda, 0xa5, 0x72, 0xd9, 0x10, 0x2b, 0x25, 0xad, 0xfd, 0x69,
	0x42, 0x61, 0x4f, 0xf2, 0x1c, 0x73, 0xcc, 0x09, 0x7a, 0x17, 0xa0, 0xd3, 0xc3, 0x5e, 0x68, 0xf3,
	0x51, 0x9f, 0x54, 0x8c, 0x2d, 0x63, 0xbb, 0x64, 0xe5, 0xa5, 0xe4, 0xe1, 0xa8, 0x4f, 0xd0, 0xff,
	0x20, 0xa7, 0x8e, 0x3d, 0xb7, 0x92, 0xd9, 0x32, 0xb6, 0xf3, 0x56, 0x56, 0xee, 0x0f, 0x5c, 0xf4,
	0x1e, 0x14, 0xfb, 0x38, 0xc2, 0xc9, 0xf1, 0xa2, 0xc4, 0x16, 0x12, 0xd9, 0x81, 0x8b, 0xee, 0xc0,
	0x7f, 0x1d, 0x42, 0x4e, 0x46, 0x36, 0xee, 0x70, 0x6f, 0x88, 0xb9, 0x47, 0x43, 0xbb, 0x47, 0x84,
	0xc7, 0x15, 0x53, 0xde, 0xfe, 0x8f, 0x3c, 0xde, 0x4d, 0x4e, 0xf7, 0xe5, 0x21, 0x3a, 0x82, 0xab,
	0x3e, 0xe6, 0x84, 0x71, 0x5b, 0xc1, 0x35, 0xe6, 0xca, 0x96, 0xb1, 0x5d, 0x68, 0x6d, 0xd4, 0x45,
	0xdc, 0x44, 0x68, 0xea, 0x3a, 0x20, 0xc3, 0x66, 0x5d, 0x01, 0xdb, 0xe6, 0x8b, 0xd3, 0xea, 0x82,
	0xb5, 0xaa, 0xc0, 0x6d, 0x81, 0xd5, 0x8c, 0x35, 0x28, 0x05, 0x41, 0x64, 0x47, 0x94, 0x72, 0xbb,
	0x87, 0x59, 0xaf, 0xb2, 0xb4, 0x65, 0x6c, 0x17, 0xad, 0x42, 0x10, 0x44, 0x16, 0xa5, 0x7c, 0x1f,
	0xb3, 0x5e, 0x4a, 0xab, 0xf2, 0x49, 0x6b, 0xcd, 0xbe, 0x99, 0xd6, 0x3d, 0x81, 0xd5, 0x5a, 0xef,
	0x41, 0xe9, 0x24, 0xa2, 0xcf, 0x48, 0xc2, 0x95, 0xbb, 0x24, 0x57, 0x51, 0xc1, 0x34, 0xcd, 0x23,
	0x28, 0xe1, 0x01, 0xef, 0xd1, 0xc8, 0xe3, 0x23, 0x9b, 0x11, 0x5e, 0xc9, 0x4b, 0x9a, 0x7a, 0x7d,
	0x46, 0x02, 0xd5, 0xa5, 0xf7, 0xbb, 0x31, 0xec, 0x98, 0x24, 0xd4, 0x38, 0x25, 0x43, 0x0e, 0xa0,
	0x90, 0x3c, 0xe5, 0xf6, 0x24, 0x3f, 0xbc, 0x05, 0x7f, 0x59, 0xf0, 0xa5, 0xe5, 0x77, 0xcd, 0xaf,
	0xbf, 0xab, 0x2e, 0xd4, 0x3e, 0x83, 0xd5, 0x29, 0x08, 0x5a, 0x86, 0x8c, 0xe7, 0xca, 0xac, 0x33,
	0xad, 0x8c, 0xe7, 0xa2, 0x32, 0x2c, 0xfa, 0x24, 0x94, 0x99, 0x56, 0xb2, 0xc4, 0x12, 0x21, 0x30,
	0xc5, 0xa3, 0xc9, 0xec, 0x2a, 0x5a, 0x72, 0xad, 0x09, 0x9b, 0x50, 0x38, 0xc2, 0x23, 0x9f, 0x62,
	0xf7, 0x80, 0x93, 0x20, 0x45, 0x55, 0x94, 0x54, 0x08, 0x4c, 0x17, 0x73, 0x2c, 0xb9, 0x8a, 0x96,
	0x5c, 0xd7, 0xbe, 0x37, 0x00, 0xf6, 0x68, 0x10, 0x78, 0x3c, 0x20, 0x21, 0x47, 0x9f, 0x40, 0xae,
	0xaf, 0x18, 0x58, 0xc5, 0xd8, 0x5a, 0xdc, 0x2e, 0xb4, 0xb6, 0x67, 0xba, 0x9c, 0x52, 0xa7, 0x9d,
	0x4d, 0xf0, 0xa2, 0x1a, 0x1c, 0x9f, 0x76, 0x9e, 0xd8, 0xe1, 0x20, 0x70, 0x48, 0xa4, 0x5d, 0x28,
	0x48, 0xd9, 0x03, 0x29, 0x42, 0xdb, 0x50, 0x1e, 0x62, 0xdf, 0x73, 0x31, 0xa7, 0x91, 0x08, 0x73,
	0x5c, 0x34, 0xa6, 0xb5, 0x9c, 0xc8, 0x8f, 0x09, 0x3f, 0x70, 0xb5, 0x83, 0xf7, 0x20, 0x7f, 0xec,
	0x75, 0x43, 0xcc, 0x07, 0x11, 0x41, 0x6b, 0x70, 0xc5, 0x0b, 0x5d, 0xf2, 0x54, 0x97, 0xa8, 0xda,
	0xa0, 0x77, 0x20, 0xcf, 0xe2, 0x2b, 0xda, 0xd3, 0xb1, 0x40, 0xd3, 0xfc, 0x64, 0x40, 0x59, 0xf0,
	0x10, 0x37, 0xe5, 0xfa, 0x21, 0x40, 0x27, 0xd9, 0x49, 0xce, 0x42, 0xeb, 0xfa, 0x4c, 0xe7, 0xc7,
	0x60, 0xed, 0x7b, 0x8a, 0x00, 0xdd, 0x07, 0x48, 0xd4, 0xb2, 0x4a, 0x46, 0xc6, 0xf2, 0xc3, 0x99,
	0x74, 0x89, 0x67, 0x31, 0xdb, 0x18, 0xaf, 0xed, 0xfe, 0x31, 0x03, 0x39, 0x99, 0x31, 0x87, 0x87,
	0x16, 0xfa, 0x0a, 0x56, 0x99, 0xf4, 0xc1, 0x9e, 0x32, 0x7b, 0x67, 0xae, 0x9e, 0xb4, 0xe7, 0x71,
	0x96, 0xb2, 0xf3, 0x11, 0xb9, 0x01, 0xe5, 0xc4, 0x04, 0xbb, 0x1f, 0x51, 0x7a, 0xa2, 0x1c, 0x29,
	0x5a, 0x2b, 0x89, 0xfc, 0x48, 0x8a, 0xd1, 0x00, 0x36, 0x44, 0x33, 0xf1, 0x09, 0x1e, 0x12, 0x66,
	0xe3, 0xd0, 0xb5, 0x1d, 0xcc, 0x3b, 0x3d, 0x85, 0x92, 0x4f, 0x5a, 0x68, 0xdd, 0x9e, 0x69, 0xd5,
	0xe1, 0xa1, 0x75, 0x5f, 0xa2, 0x77, 0x43, 0xb7, 0x2d, 0xb0, 0x92, 0x59, 0xdb, 0xb6, 0x1e, 0x04,
	0xd1, 0x05, 0xa7, 0xa2, 0x17, 0x0b, 0xb5, 0xcc, 0x7b, 0x46, 0x64, 0xfb, 0x34, 0xad, 0x6c, 0x10,
	0x44, 0xc7, 0xde, 0xb3, 0xf8, 0xa5, 0x7f, 0x36, 0x60, 0xfd, 0x62, 0x66, 0xd4, 0x86, 0x25, 0x65,
	0xae, 0x4e, 0xf4, 0xf7, 0x2f, 0x61, 0x5e, 0x6c, 0x8f, 0x46, 0xa2, 0xcf, 0x61, 0x45, 0xe8, 0x4f,
	0xfb, 0x9a, 0x91, 0xbe, 0x7e, 0x34, 0x8f, 0x6c, 0xca, 0x45, 0xd1, 0x8c, 0xc7, 0xc2, 0xda, 0x0f,
	0x19, 0xc8, 0x6a, 0x9d, 0xa8, 0x02, 0xd9, 0x21, 0x89, 0x98, 0x47, 0x43, 0x9d, 0xea, 0xf1, 0x16,
	0x3d, 0x81, 0xf5, 0x3e, 0x8e, 0x48, 0xc8, 0x75, 0x8d, 0xc9, 0xc8, 0xcb, 0x66, 0xae, 0xcc, 0xb8,
	0x35, 0xa7, 0x78, 0x05, 0x54, 0x95, 0xe2, 0x6e, 0xe8, 0x8a, 0x8e, 0xaf, 0x8d, 0xb9, 0xda, 0x9f,
	0x3e, 0x42, 0x01, 0x54, 0xd4, 0xb7, 0xe7, 0x82, 0xf6, 0xb8, 0xf8, 0x16, 0xed, 0x51, 0x7d, 0xf1,
	0x1e, 0x9c, 0xeb, 0x91, 0xe8, 0x3a, 0xac, 0x8c, 0x3f, 0xa6, 0x3d, 0x22, 0x3a, 0x92, 0x29, 0xcb,
	0x79, 0x39, 0x11, 0xef, 0x0b, 0xa9, 0x7e, 0xe9, 0x2f, 0xe1, 0xea, 0x05, 0xfe, 0xa0, 0x6b, 0x50,
	0x9a, 0x88, 0x90, 0x8e, 0x60, 0x31, 0xed, 0x20, 0xaa, 0x42, 0x41, 0x5f, 0x4a, 0x62, 0x57, 0xb4,
	0x40, 0x89, 0x04, 0x4b, 0xad, 0x0b, 0xa5, 0x89, 0x37, 0x13, 0xbd, 0xcd, 0x27, 0xf8, 0xc4, 0x96,
	0x3d, 0x47, 0xa7, 0x90, 0x69, 0x15, 0x84, 0xec, 0x40, 0x89, 0xc4, 0x18, 0x21, 0xaf, 0x74, 0xe8,
	0x20, 0xe4, 0x92, 0xd3, 0xb4, 0xf2, 0x42, 0xb2, 0x27, 0x04, 0xb2, 0x7b, 0x71, 0x12, 0xb0, 0xca,
	0xa2, 0xac, 0x28, 0xb5, 0xa9, 0x85, 0xb0, 0xbc, 0x47, 0x43, 0x46, 0x42, 0x36, 0x60, 0x6a, 0x1a,
	0x69, 0x43, 0x3e, 0x19, 0x63, 0x74, 0x79, 0x6f, 0xd4, 0xd5, 0xa0, 0x53, 0x8f, 0x07, 0x9d, 0xfa,
	0xc3, 0xf8, 0x46, 0x3b, 0x27, 0x42, 0xfa, 0xfc, 0xf7, 0xaa, 0x61, 0x8d, 0x61, 0xc9, 0x17, 0x23,
	0x33, 0xf5, 0xc5, 0xf8, 0xc5, 0x80, 0xe5, 0xe3, 0x81, 0x93, 0x44, 0x93, 0x44, 0x13, 0xf3, 0x8d,
	0x31, 0x35, 0xdf, 0xcc, 0xeb, 0xe8, 0xc9, 0x95, 0x9e, 0x64, 0xd3, 0x1f, 0x29, 0x75, 0x45, 0x2b,
	0xf8, 0x34, 0xed, 0x91, 0x79, 0x89, 0x3e, 0x2b, 0x03, 0x91, 0xae, 0x95, 0x31, 0x5e, 0xbb, 0x31,
	0x80, 0x95, 0x49, 0x2f, 0x18, 0x7a, 0x0c, 0x65, 0xa6, 0x45, 0xda, 0x96, 0xb8, 0xd0, 0x3f, 0x9e,
	0xad, 0x6c, 0x82, 0x47, 0x2b, 0x5c, 0x61, 0x93, 0xec, 0x5a, 0xed, 0xaf, 0x19, 0x58, 0x39, 0x4a,
	0x27, 0xe3, 0xdc, 0xf0, 0x4d, 0x8c, 0x87, 0x99, 0xe9, 0xf1, 0xf0, 0x16, 0xac, 0x45, 0xc4, 0xc7,
	0x23, 0x12, 0xe9, 0x89, 0x4b, 0x47, 0x5a, 0x4d, 0x92, 0x48, 0x9f, 0xc9, 0x81, 0xea, 0x6f, 0x02,
	0x6e, 0x4e, 0x07, 0x7c, 0x1d, 0x96, 0x74, 0xf7, 0xbe, 0x22, 0x73, 0x4d, 0xef, 0x04, 0x54, 0x81,
	0x54, 0x1a, 0xcb, 0x01, 0xb0, 0x64, 0x15, 0x94, 0x4c, 0xa6, 0x71, 0xea, 0x8a, 0x4a, 0xe3, 0x6c,
	0xfa, 0x8a, 0x4a, 0xe4, 0x89, 0xe7, 0xcc, 0xfd, 0x2b, 0xcf, 0x39, 0x82, 0xf2, 0xb9, 0xb0, 0x32,
	0x64, 0xc3, 0xea, 0x64, 0x3b, 0x18, 0x3f, 0xe8, 0xcd, 0x79, 0x5d, 0x0e, 0x4f, 0xbf, 0x68, 0xb9,
	0x7f, 0x4e, 0x81, 0x56, 0x7d, 0x1f, 0x60, 0x6c, 0x9f, 0x18, 0xbe, 0x9e, 0x90, 0x91, 0x1e, 0xa1,
	0xc4, 0x52, 0x94, 0xed, 0x10, 0xfb, 0x83, 0x78, 0xb4, 0x50, 0x9b, 0x54, 0x84, 0x17, 0xd3, 0x11,
	0xae, 0x7d, 0x9b, 0x81, 0x25, 0xfd, 0x08, 0xfb, 0x90, 0x57, 0xdd, 0x33, 0x08, 0x22, 0x5d, 0xc7,
	0x1f, 0xcc, 0x6f, 0x97, 0xa2, 0xeb, 0xe8, 0xb9, 0x4a, 0xa2, 0x0f, 0x83, 0x08, 0x3d, 0xba, 0x20,
	0xb3, 0x55, 0xbb, 0xbf, 0xf9, 0x06, 0x99, 0xcd, 0xf6, 0xa7, 0xd3, 0x1a, 0x3d, 0xbe, 0x28, 0xc8,
	0x8b, 0x97, 0x98, 0x29, 0xce, 0x3f, 0xd7, 0xfe, 0x05, 0x11, 0x6e, 0xe7, 0x21, 0x1b, 0x10, 0xc6,
	0x70, 0x97, 0xd4, 0xbe, 0xc9, 0x40, 0xf1, 0xd0, 0x63, 0x0e, 0xe9, 0xe1, 0xa1, 0x47, 0x07, 0x11,
	0x6a, 0x42, 0x5e, 0xd1, 0x26, 0x75, 0xd3, 0x5e, 0x7b, 0x7d, 0x5a, 0x2d, 0x8f, 0x70, 0xe0, 0xdf,
	0xad, 0x25, 0x47, 0x35, 0x2b, 0xa7, 0xd6, 0x07, 0x2e, 0x72, 0x20, 0xa7, 0x73, 0xb3, 0xa9, 0xfd,
	0xbf, 0x36, 0xd3, 0x46, 0xfd, 0xfe, 0x35, 0x11, 0xce, 0xb3, 0xd3, 0x6a, 0x56, 0xed, 0x9b, 0xaf,
	0x4f, 0xab, 0x2b, 0x4a, 0x4b, 0xcc, 0x56, 0xb3, 0xb2, 0x6a, 0xd9, 0x4c, 0xe9, 0x68, 0xe9, 0x38,
	0xfc, 0x13, 0x1d, 0xad, 0x29, 0x1d, 0xad, 0x44, 0x47, 0x4b, 0x25, 0x5e, 0xfb, 0xf1, 0x8b, 0xb3,
	0x4d, 0xe3, 0xe5, 0xd9, 0xa6, 0xf1, 0xc7, 0xd9, 0xa6, 0xf1, 0xfc, 0xd5, 0xe6, 0xc2, 0xcb, 0x57,
	0x9b, 0x0b, 0xbf, 0xbd, 0xda, 0x5c, 0xf8, 0xa2, 0xdd, 0xf5, 0x78, 0x6f, 0xe0, 0xd4, 0x3b, 0x34,
	0x68, 0x74, 0x28, 0x0b, 0x28, 0x6b, 0x78, 0x4e, 0x67, 0xa7, 0x4b, 0x1b, 0xc3, 0x3b, 0x8d, 0x80,
	0xba, 0x03, 0x9f, 0x30, 0xf5, 0x7f, 0xbd, 0x13, 0xff, 0x60, 0x37, 0x6f, 0xed, 0xc4, 0xff, 0xd8,
	0xe2, 0x27, 0x96, 0x39, 0x4b, 0xf2, 0x53, 0x71, 0xfb, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0b,
	0x3a, 0xc1, 0x45, 0x8c, 0x0f, 0x00, 0x00,
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.NextAuthoritySet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.AuthoritySet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.FrozenHeight.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.LatestChainHeight.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.MmrRootHash) > 0 {
		i -= len(m.MmrRootHash)
		copy(dAtA[i:], m.MmrRootHash)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.MmrRootHash)))
		i--
		dAtA[i] = 0x32
	}
	{
		size, err := m.LatestBeefyHeight.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.BeefyActivationHeight != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.BeefyActivationHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.ParachainId != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.ParachainId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainType != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.ChainType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BeefyAuthoritySet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeefyAuthoritySet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeefyAuthoritySet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Len != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PayloadItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayloadItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Commitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Commitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidatorSetId != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.ValidatorSetId))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockNumber != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Payloads) > 0 {
		for iNdEx := len(m.Payloads) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payloads[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrandpa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SignedCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrandpa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BeefyMMR) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeefyMMR) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeefyMMR) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MmrSize != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.MmrSize))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.MmrLeavesAndBatchProof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SignatureProofs) > 0 {
		for iNdEx := len(m.SignatureProofs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SignatureProofs[iNdEx])
			copy(dAtA[i:], m.SignatureProofs[iNdEx])
			i = encodeVarintGrandpa(dAtA, i, uint64(len(m.SignatureProofs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.SignedCommitment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MMRLeavesAndBatchProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MMRLeavesAndBatchProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MMRLeavesAndBatchProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MmrBatchProof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Leaves) > 0 {
		for iNdEx := len(m.Leaves) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Leaves[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrandpa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MMRLeaf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MMRLeaf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MMRLeaf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParachainHeads) > 0 {
		i -= len(m.ParachainHeads)
		copy(dAtA[i:], m.ParachainHeads)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ParachainHeads)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.BeefyNextAuthoritySet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ParentNumberAndHash.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Version != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ParentNumberAndHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParentNumberAndHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParentNumberAndHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParentHash) > 0 {
		i -= len(m.ParentHash)
		copy(dAtA[i:], m.ParentHash)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ParentHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.ParentNumber != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.ParentNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MMRBatchProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MMRBatchProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MMRBatchProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Items[iNdEx])
			copy(dAtA[i:], m.Items[iNdEx])
			i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Items[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.LeafCount != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.LeafCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LeafIndexes) > 0 {
		dAtA13 := make([]byte, len(m.LeafIndexes)*10)
		var j12 int
		for _, num := range m.LeafIndexes {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintGrandpa(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x12
	}
	n14, err14 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err14 != nil {
		return 0, err14
	}
	i -= n14
	i = encodeVarintGrandpa(dAtA, i, uint64(n14))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubchainHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubchainHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubchainHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.BlockHeader) > 0 {
		i -= len(m.BlockHeader)
		copy(dAtA[i:], m.BlockHeader)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.BlockHeader)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockNumber != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubchainHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubchainHeaders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubchainHeaders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubchainHeaders) > 0 {
		for iNdEx := len(m.SubchainHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubchainHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrandpa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ParachainHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParachainHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParachainHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.HeaderCount != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.HeaderCount))
		i--
		dAtA[i] = 0x38
	}
	if m.HeaderIndex != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.HeaderIndex))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Proofs) > 0 {
		for iNdEx := len(m.Proofs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Proofs[iNdEx])
			copy(dAtA[i:], m.Proofs[iNdEx])
			i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Proofs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BlockHeader) > 0 {
		i -= len(m.BlockHeader)
		copy(dAtA[i:], m.BlockHeader)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.BlockHeader)))
		i--
		dAtA[i] = 0x22
	}
	if m.RelayerChainNumber != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.RelayerChainNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.ParachainId != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.ParachainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParachainHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParachainHeaders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParachainHeaders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParachainHeaders) > 0 {
		for iNdEx := len(m.ParachainHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ParachainHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrandpa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StateProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proofs) > 0 {
		for iNdEx := len(m.Proofs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Proofs[iNdEx])
			copy(dAtA[i:], m.Proofs[iNdEx])
			i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Proofs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size := m.Message.Size()
			i -= size
			if _, err := m.Message.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	{
		size, err := m.BeefyMmr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Header_SubchainHeaders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_SubchainHeaders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubchainHeaders != nil {
		{
			size, err := m.SubchainHeaders.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrandpa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Header_ParachainHeaders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_ParachainHeaders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ParachainHeaders != nil {
		{
			size, err := m.ParachainHeaders.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrandpa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Misbehaviour) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Misbehaviour) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Misbehaviour) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Header2.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Header1.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGrandpa(dAtA []byte, offset int, v uint64) int {
	offset -= sovGrandpa(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainType != 0 {
		n += 1 + sovGrandpa(uint64(m.ChainType))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.ParachainId != 0 {
		n += 1 + sovGrandpa(uint64(m.ParachainId))
	}
	if m.BeefyActivationHeight != 0 {
		n += 1 + sovGrandpa(uint64(m.BeefyActivationHeight))
	}
	l = m.LatestBeefyHeight.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = len(m.MmrRootHash)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = m.LatestChainHeight.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.FrozenHeight.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.AuthoritySet.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.NextAuthoritySet.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	return n
}

func (m *BeefyAuthoritySet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGrandpa(uint64(m.Id))
	}
	if m.Len != 0 {
		n += 1 + sovGrandpa(uint64(m.Len))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *PayloadItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *Commitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payloads) > 0 {
		for _, e := range m.Payloads {
			l = e.Size()
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	if m.BlockNumber != 0 {
		n += 1 + sovGrandpa(uint64(m.BlockNumber))
	}
	if m.ValidatorSetId != 0 {
		n += 1 + sovGrandpa(uint64(m.ValidatorSetId))
	}
	return n
}

func (m *Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovGrandpa(uint64(m.Index))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *SignedCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Commitment.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	return n
}

func (m *BeefyMMR) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SignedCommitment.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	if len(m.SignatureProofs) > 0 {
		for _, b := range m.SignatureProofs {
			l = len(b)
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	l = m.MmrLeavesAndBatchProof.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	if m.MmrSize != 0 {
		n += 1 + sovGrandpa(uint64(m.MmrSize))
	}
	return n
}

func (m *MMRLeavesAndBatchProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Leaves) > 0 {
		for _, e := range m.Leaves {
			l = e.Size()
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	l = m.MmrBatchProof.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	return n
}

func (m *MMRLeaf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovGrandpa(uint64(m.Version))
	}
	l = m.ParentNumberAndHash.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.BeefyNextAuthoritySet.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = len(m.ParachainHeads)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *ParentNumberAndHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParentNumber != 0 {
		n += 1 + sovGrandpa(uint64(m.ParentNumber))
	}
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *MMRBatchProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LeafIndexes) > 0 {
		l = 0
		for _, e := range m.LeafIndexes {
			l += sovGrandpa(uint64(e))
		}
		n += 1 + sovGrandpa(uint64(l)) + l
	}
	if m.LeafCount != 0 {
		n += 1 + sovGrandpa(uint64(m.LeafCount))
	}
	if len(m.Items) > 0 {
		for _, b := range m.Items {
			l = len(b)
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovGrandpa(uint64(l))
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *SubchainHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovGrandpa(uint64(m.BlockNumber))
	}
	l = len(m.BlockHeader)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	return n
}

func (m *SubchainHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubchainHeaders) > 0 {
		for _, e := range m.SubchainHeaders {
			l = e.Size()
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	return n
}

func (m *ParachainHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.ParachainId != 0 {
		n += 1 + sovGrandpa(uint64(m.ParachainId))
	}
	if m.RelayerChainNumber != 0 {
		n += 1 + sovGrandpa(uint64(m.RelayerChainNumber))
	}
	l = len(m.BlockHeader)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if len(m.Proofs) > 0 {
		for _, b := range m.Proofs {
			l = len(b)
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	if m.HeaderIndex != 0 {
		n += 1 + sovGrandpa(uint64(m.HeaderIndex))
	}
	if m.HeaderCount != 0 {
		n += 1 + sovGrandpa(uint64(m.HeaderCount))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	return n
}

func (m *ParachainHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ParachainHeaders) > 0 {
		for _, e := range m.ParachainHeaders {
			l = e.Size()
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	return n
}

func (m *StateProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if len(m.Proofs) > 0 {
		for _, b := range m.Proofs {
			l = len(b)
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BeefyMmr.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *Header_SubchainHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubchainHeaders != nil {
		l = m.SubchainHeaders.Size()
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}
func (m *Header_ParachainHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParachainHeaders != nil {
		l = m.ParachainHeaders.Size()
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}
func (m *Misbehaviour) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = m.Header1.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.Header2.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	return n
}

func sovGrandpa(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGrandpa(x uint64) (n int) {
	return sovGrandpa(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainType", wireType)
			}
			m.ChainType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainId", wireType)
			}
			m.ParachainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParachainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeefyActivationHeight", wireType)
			}
			m.BeefyActivationHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeefyActivationHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBeefyHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatestBeefyHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrRootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmrRootHash = append(m.MmrRootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MmrRootHash == nil {
				m.MmrRootHash = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestChainHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatestChainHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FrozenHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthoritySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AuthoritySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextAuthoritySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NextAuthoritySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeefyAuthoritySet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeefyAuthoritySet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeefyAuthoritySet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayloadItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayloadItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayloadItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payloads", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payloads = append(m.Payloads, PayloadItem{})
			if err := m.Payloads[len(m.Payloads)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSetId", wireType)
			}
			m.ValidatorSetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorSetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeefyMMR) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeefyMMR: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeefyMMR: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SignedCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureProofs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignatureProofs = append(m.SignatureProofs, make([]byte, postIndex-iNdEx))
			copy(m.SignatureProofs[len(m.SignatureProofs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrLeavesAndBatchProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MmrLeavesAndBatchProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrSize", wireType)
			}
			m.MmrSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MmrSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MMRLeavesAndBatchProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MMRLeavesAndBatchProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MMRLeavesAndBatchProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leaves = append(m.Leaves, MMRLeaf{})
			if err := m.Leaves[len(m.Leaves)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrBatchProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MmrBatchProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MMRLeaf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MMRLeaf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MMRLeaf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentNumberAndHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ParentNumberAndHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeefyNextAuthoritySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BeefyNextAuthoritySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeads", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParachainHeads = append(m.ParachainHeads[:0], dAtA[iNdEx:postIndex]...)
			if m.ParachainHeads == nil {
				m.ParachainHeads = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParentNumberAndHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParentNumberAndHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParentNumberAndHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentNumber", wireType)
			}
			m.ParentNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = append(m.ParentHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentHash == nil {
				m.ParentHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MMRBatchProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MMRBatchProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MMRBatchProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGrandpa
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LeafIndexes = append(m.LeafIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGrandpa
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGrandpa
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGrandpa
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LeafIndexes) == 0 {
					m.LeafIndexes = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGrandpa
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LeafIndexes = append(m.LeafIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafIndexes", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafCount", wireType)
			}
			m.LeafCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, make([]byte, postIndex-iNdEx))
			copy(m.Items[len(m.Items)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubchainHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubchainHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubchainHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHeader = append(m.BlockHeader[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockHeader == nil {
				m.BlockHeader = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubchainHeaders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubchainHeaders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubchainHeaders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubchainHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubchainHeaders = append(m.SubchainHeaders, SubchainHeader{})
			if err := m.SubchainHeaders[len(m.SubchainHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParachainHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParachainHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParachainHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainId", wireType)
			}
			m.ParachainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParachainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerChainNumber", wireType)
			}
			m.RelayerChainNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelayerChainNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHeader = append(m.BlockHeader[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockHeader == nil {
				m.BlockHeader = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proofs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proofs = append(m.Proofs, make([]byte, postIndex-iNdEx))
			copy(m.Proofs[len(m.Proofs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderIndex", wireType)
			}
			m.HeaderIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderCount", wireType)
			}
			m.HeaderCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeaderCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParachainHeaders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParachainHeaders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParachainHeaders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParachainHeaders = append(m.ParachainHeaders, ParachainHeader{})
			if err := m.ParachainHeaders[len(m.ParachainHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proofs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proofs = append(m.Proofs, make([]byte, postIndex-iNdEx))
			copy(m.Proofs[len(m.Proofs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeefyMmr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BeefyMmr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubchainHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubchainHeaders{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Header_SubchainHeaders{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParachainHeaders{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Header_ParachainHeaders{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Misbehaviour) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Misbehaviour: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Misbehaviour: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGrandpa(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGrandpa
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGrandpa
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGrandpa
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGrandpa        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGrandpa          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGrandpa = fmt.Errorf("proto: unexpected end of group")
)
