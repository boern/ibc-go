// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/lightclients/grandpa/v1/grandpa.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MmrRoot struct {
	//uint32 block_number = 1
	//      [(gogoproto.nullable) = false, (gogoproto.moretags) = "yaml:\"block_number\""];
	/// Block Header.
	BlockHeader          BlockHeader          `protobuf:"bytes,1,opt,name=block_header,json=blockHeader,proto3" json:"block_header"`
	SignedCommitment     SignedCommitment     `protobuf:"bytes,2,opt,name=signed_commitment,json=signedCommitment,proto3" json:"signed_commitment" yaml:"signed_commitment"`
	ValidatorMerkleProof ValidatorMerkleProof `protobuf:"bytes,3,opt,name=validator_merkle_proof,json=validatorMerkleProof,proto3" json:"validator_merkle_proof" yaml:"validator_merkle_proof"`
	MmrLeaf              MmrLeaf              `protobuf:"bytes,4,opt,name=mmr_leaf,json=mmrLeaf,proto3" json:"mmr_leaf" yaml:"mmr_leaf"`
	MmrLeafProof         MmrLeafProof         `protobuf:"bytes,5,opt,name=mmr_leaf_proof,json=mmrLeafProof,proto3" json:"mmr_leaf_proof" yaml:"mmr_leaf_proof"`
}

func (m *MmrRoot) Reset()         { *m = MmrRoot{} }
func (m *MmrRoot) String() string { return proto.CompactTextString(m) }
func (*MmrRoot) ProtoMessage()    {}
func (*MmrRoot) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{0}
}
func (m *MmrRoot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MmrRoot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MmrRoot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MmrRoot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MmrRoot.Merge(m, src)
}
func (m *MmrRoot) XXX_Size() int {
	return m.Size()
}
func (m *MmrRoot) XXX_DiscardUnknown() {
	xxx_messageInfo_MmrRoot.DiscardUnknown(m)
}

var xxx_messageInfo_MmrRoot proto.InternalMessageInfo

func (m *MmrRoot) GetBlockHeader() BlockHeader {
	if m != nil {
		return m.BlockHeader
	}
	return BlockHeader{}
}

func (m *MmrRoot) GetSignedCommitment() SignedCommitment {
	if m != nil {
		return m.SignedCommitment
	}
	return SignedCommitment{}
}

func (m *MmrRoot) GetValidatorMerkleProof() ValidatorMerkleProof {
	if m != nil {
		return m.ValidatorMerkleProof
	}
	return ValidatorMerkleProof{}
}

func (m *MmrRoot) GetMmrLeaf() MmrLeaf {
	if m != nil {
		return m.MmrLeaf
	}
	return MmrLeaf{}
}

func (m *MmrRoot) GetMmrLeafProof() MmrLeafProof {
	if m != nil {
		return m.MmrLeafProof
	}
	return MmrLeafProof{}
}

type SignedCommitment struct {
	Commitment Commitment  `protobuf:"bytes,1,opt,name=commitment,proto3" json:"commitment" yaml:"commitment"`
	Signatures []Signature `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures" yaml:"signatures"`
}

func (m *SignedCommitment) Reset()         { *m = SignedCommitment{} }
func (m *SignedCommitment) String() string { return proto.CompactTextString(m) }
func (*SignedCommitment) ProtoMessage()    {}
func (*SignedCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{1}
}
func (m *SignedCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedCommitment.Merge(m, src)
}
func (m *SignedCommitment) XXX_Size() int {
	return m.Size()
}
func (m *SignedCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_SignedCommitment proto.InternalMessageInfo

func (m *SignedCommitment) GetCommitment() Commitment {
	if m != nil {
		return m.Commitment
	}
	return Commitment{}
}

func (m *SignedCommitment) GetSignatures() []Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type Commitment struct {
	// block height
	BlockNumber uint32 `protobuf:"varint,1,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty" yaml:"block_number"`
	Payload     []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty" yaml:"payload"`
	//validator_set_id
	ValidatorSetId uint64 `protobuf:"varint,3,opt,name=validator_set_id,json=validatorSetId,proto3" json:"validator_set_id,omitempty" yaml:"validator_set_id"`
}

func (m *Commitment) Reset()         { *m = Commitment{} }
func (m *Commitment) String() string { return proto.CompactTextString(m) }
func (*Commitment) ProtoMessage()    {}
func (*Commitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{2}
}
func (m *Commitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commitment.Merge(m, src)
}
func (m *Commitment) XXX_Size() int {
	return m.Size()
}
func (m *Commitment) XXX_DiscardUnknown() {
	xxx_messageInfo_Commitment.DiscardUnknown(m)
}

var xxx_messageInfo_Commitment proto.InternalMessageInfo

func (m *Commitment) GetBlockNumber() uint32 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *Commitment) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Commitment) GetValidatorSetId() uint64 {
	if m != nil {
		return m.ValidatorSetId
	}
	return 0
}

type Signature struct {
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty" yaml:"signature"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{3}
}
func (m *Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return m.Size()
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type ValidatorMerkleProof struct {
	/// Proof items (does not contain the leaf hash, nor the root obviously).
	///
	/// This vec contains all inner node hashes necessary to reconstruct the root hash given the
	/// leaf hash.
	Proof          [][]byte `protobuf:"bytes,1,rep,name=proof,proto3" json:"proof,omitempty" yaml:"proof"`
	NumberOfLeaves uint32   `protobuf:"varint,2,opt,name=number_of_leaves,json=numberOfLeaves,proto3" json:"number_of_leaves,omitempty" yaml:"number_of_leaves"`
	LeafIndex      uint32   `protobuf:"varint,3,opt,name=leaf_index,json=leafIndex,proto3" json:"leaf_index,omitempty" yaml:"leaf_index"`
	/// Leaf content.
	///pub leaf: Vec<u8>,
	Leaf []byte `protobuf:"bytes,4,opt,name=leaf,proto3" json:"leaf,omitempty" yaml:"leaf"`
}

func (m *ValidatorMerkleProof) Reset()         { *m = ValidatorMerkleProof{} }
func (m *ValidatorMerkleProof) String() string { return proto.CompactTextString(m) }
func (*ValidatorMerkleProof) ProtoMessage()    {}
func (*ValidatorMerkleProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{4}
}
func (m *ValidatorMerkleProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorMerkleProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorMerkleProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorMerkleProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorMerkleProof.Merge(m, src)
}
func (m *ValidatorMerkleProof) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorMerkleProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorMerkleProof.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorMerkleProof proto.InternalMessageInfo

func (m *ValidatorMerkleProof) GetProof() [][]byte {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *ValidatorMerkleProof) GetNumberOfLeaves() uint32 {
	if m != nil {
		return m.NumberOfLeaves
	}
	return 0
}

func (m *ValidatorMerkleProof) GetLeafIndex() uint32 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *ValidatorMerkleProof) GetLeaf() []byte {
	if m != nil {
		return m.Leaf
	}
	return nil
}

type MmrLeaf struct {
	/// Version of the leaf format.
	/// Can be used to enable future format migrations and compatibility.
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	/// Current block parent number and hash.
	ParentNumberAndHash ParentNumberAndHash `protobuf:"bytes,2,opt,name=parent_number_and_hash,json=parentNumberAndHash,proto3" json:"parent_number_and_hash" yaml:"parent_number_and_hash"`
	/// A merkle root of the next BEEFY authority set.
	BeefyNextAuthoritySet ValidatorSet `protobuf:"bytes,3,opt,name=beefy_next_authority_set,json=beefyNextAuthoritySet,proto3" json:"beefy_next_authority_set" yaml:"beefy_next_authority_set"`
	/// A merkle root of all registered parachain heads.
	ParachainHeads []byte `protobuf:"bytes,4,opt,name=parachain_heads,json=parachainHeads,proto3" json:"parachain_heads,omitempty" yaml:"parachain_heads"`
}

func (m *MmrLeaf) Reset()         { *m = MmrLeaf{} }
func (m *MmrLeaf) String() string { return proto.CompactTextString(m) }
func (*MmrLeaf) ProtoMessage()    {}
func (*MmrLeaf) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{5}
}
func (m *MmrLeaf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MmrLeaf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MmrLeaf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MmrLeaf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MmrLeaf.Merge(m, src)
}
func (m *MmrLeaf) XXX_Size() int {
	return m.Size()
}
func (m *MmrLeaf) XXX_DiscardUnknown() {
	xxx_messageInfo_MmrLeaf.DiscardUnknown(m)
}

var xxx_messageInfo_MmrLeaf proto.InternalMessageInfo

func (m *MmrLeaf) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *MmrLeaf) GetParentNumberAndHash() ParentNumberAndHash {
	if m != nil {
		return m.ParentNumberAndHash
	}
	return ParentNumberAndHash{}
}

func (m *MmrLeaf) GetBeefyNextAuthoritySet() ValidatorSet {
	if m != nil {
		return m.BeefyNextAuthoritySet
	}
	return ValidatorSet{}
}

func (m *MmrLeaf) GetParachainHeads() []byte {
	if m != nil {
		return m.ParachainHeads
	}
	return nil
}

type ParentNumberAndHash struct {
	BlockNumber uint32 `protobuf:"varint,1,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty" yaml:"block_number"`
	// header hash
	MmrRoot []byte `protobuf:"bytes,2,opt,name=mmr_root,json=mmrRoot,proto3" json:"mmr_root,omitempty" yaml:"mmr_root"`
}

func (m *ParentNumberAndHash) Reset()         { *m = ParentNumberAndHash{} }
func (m *ParentNumberAndHash) String() string { return proto.CompactTextString(m) }
func (*ParentNumberAndHash) ProtoMessage()    {}
func (*ParentNumberAndHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{6}
}
func (m *ParentNumberAndHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParentNumberAndHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParentNumberAndHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParentNumberAndHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParentNumberAndHash.Merge(m, src)
}
func (m *ParentNumberAndHash) XXX_Size() int {
	return m.Size()
}
func (m *ParentNumberAndHash) XXX_DiscardUnknown() {
	xxx_messageInfo_ParentNumberAndHash.DiscardUnknown(m)
}

var xxx_messageInfo_ParentNumberAndHash proto.InternalMessageInfo

func (m *ParentNumberAndHash) GetBlockNumber() uint32 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *ParentNumberAndHash) GetMmrRoot() []byte {
	if m != nil {
		return m.MmrRoot
	}
	return nil
}

type ValidatorSet struct {
	/// Id of the next set.
	///
	/// Id is required to correlate BEEFY signed commitments with the validator set.
	/// Light Client can easily verify that the commitment witness it is getting is
	/// produced by the latest validator set.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	/// Number of validators in the set.
	///
	/// Some BEEFY Light Clients may use an interactive protocol to verify only subset
	/// of signatures. We put set length here, so that these clients can verify the minimal
	/// number of required signatures.
	Len uint32 `protobuf:"varint,2,opt,name=len,proto3" json:"len,omitempty"`
	/// Merkle Root Hash build from BEEFY AuthorityIds.
	///
	/// This is used by Light Clients to confirm that the commitments are signed by the correct
	/// validator set. Light Clients using interactive protocol, might verify only subset of
	/// signatures, hence don't require the full list here (will receive inclusion proofs).
	Root []byte `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
}

func (m *ValidatorSet) Reset()         { *m = ValidatorSet{} }
func (m *ValidatorSet) String() string { return proto.CompactTextString(m) }
func (*ValidatorSet) ProtoMessage()    {}
func (*ValidatorSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{7}
}
func (m *ValidatorSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorSet.Merge(m, src)
}
func (m *ValidatorSet) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorSet.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorSet proto.InternalMessageInfo

func (m *ValidatorSet) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ValidatorSet) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *ValidatorSet) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

type MmrLeafProof struct {
	/// The index of the leaf the proof is for.
	LeafIndex uint64 `protobuf:"varint,1,opt,name=leaf_index,json=leafIndex,proto3" json:"leaf_index,omitempty"`
	/// Number of leaves in MMR, when the proof was generated.
	LeafCount uint64 `protobuf:"varint,2,opt,name=leaf_count,json=leafCount,proto3" json:"leaf_count,omitempty"`
	/// Proof elements (hashes of siblings of inner nodes on the path to the leaf).
	Items [][]byte `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty" yaml:"items"`
}

func (m *MmrLeafProof) Reset()         { *m = MmrLeafProof{} }
func (m *MmrLeafProof) String() string { return proto.CompactTextString(m) }
func (*MmrLeafProof) ProtoMessage()    {}
func (*MmrLeafProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{8}
}
func (m *MmrLeafProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MmrLeafProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MmrLeafProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MmrLeafProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MmrLeafProof.Merge(m, src)
}
func (m *MmrLeafProof) XXX_Size() int {
	return m.Size()
}
func (m *MmrLeafProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MmrLeafProof.DiscardUnknown(m)
}

var xxx_messageInfo_MmrLeafProof proto.InternalMessageInfo

func (m *MmrLeafProof) GetLeafIndex() uint64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *MmrLeafProof) GetLeafCount() uint64 {
	if m != nil {
		return m.LeafCount
	}
	return 0
}

func (m *MmrLeafProof) GetItems() [][]byte {
	if m != nil {
		return m.Items
	}
	return nil
}

// Client state
type ClientState struct {
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// block_number is height?
	BlockNumber uint32 `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty" yaml:"block_number"`
	// Block height when the client was frozen due to a misbehaviour
	FrozenHeight uint32      `protobuf:"varint,3,opt,name=frozen_height,json=frozenHeight,proto3" json:"frozen_height,omitempty" yaml:"frozen_height"`
	BlockHeader  BlockHeader `protobuf:"bytes,4,opt,name=block_header,json=blockHeader,proto3" json:"block_header"`
	//latest_commitment: Option<Commitment>
	LatestCommitment *Commitment   `protobuf:"bytes,5,opt,name=latest_commitment,json=latestCommitment,proto3" json:"latest_commitment,omitempty"`
	ValidatorSet     *ValidatorSet `protobuf:"bytes,6,opt,name=validator_set,json=validatorSet,proto3" json:"validator_set,omitempty"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{9}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

// Consensus state
type ConsensusState struct {
	/// The parent hash.
	ParentHash []byte `protobuf:"bytes,1,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	/// The block number.
	BlockNumber uint32 `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	/// The state trie merkle root
	StateRoot []byte `protobuf:"bytes,3,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	/// The merkle root of the extrinsics.
	ExtrinsicsRoot []byte `protobuf:"bytes,4,opt,name=extrinsics_root,json=extrinsicsRoot,proto3" json:"extrinsics_root,omitempty"`
	/// A chain-specific digest of data useful for light clients or referencing auxiliary data.
	Digest []byte `protobuf:"bytes,5,opt,name=digest,proto3" json:"digest,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{10}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

type Header struct {
	/// Block Header.
	BlockHeader  BlockHeader  `protobuf:"bytes,1,opt,name=block_header,json=blockHeader,proto3" json:"block_header"`
	MmrLeaf      MmrLeaf      `protobuf:"bytes,2,opt,name=mmr_leaf,json=mmrLeaf,proto3" json:"mmr_leaf" yaml:"mmr_leaf"`
	MmrLeafProof MmrLeafProof `protobuf:"bytes,3,opt,name=mmr_leaf_proof,json=mmrLeafProof,proto3" json:"mmr_leaf_proof" yaml:"mmr_leaf_proof"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{11}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

// Block Header
type BlockHeader struct {
	/// The parent hash.
	ParentHash []byte `protobuf:"bytes,1,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	/// The block number.
	BlockNumber uint32 `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	/// The state trie merkle root
	StateRoot []byte `protobuf:"bytes,3,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	/// The merkle root of the extrinsics.
	ExtrinsicsRoot []byte `protobuf:"bytes,4,opt,name=extrinsics_root,json=extrinsicsRoot,proto3" json:"extrinsics_root,omitempty"`
	/// A chain-specific digest of data useful for light clients or referencing auxiliary data.
	Digest []byte `protobuf:"bytes,5,opt,name=digest,proto3" json:"digest,omitempty"`
}

func (m *BlockHeader) Reset()         { *m = BlockHeader{} }
func (m *BlockHeader) String() string { return proto.CompactTextString(m) }
func (*BlockHeader) ProtoMessage()    {}
func (*BlockHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{12}
}
func (m *BlockHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockHeader.Merge(m, src)
}
func (m *BlockHeader) XXX_Size() int {
	return m.Size()
}
func (m *BlockHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockHeader.DiscardUnknown(m)
}

var xxx_messageInfo_BlockHeader proto.InternalMessageInfo

// Misbehaviour
// The Misbehaviour type is used for detecting misbehaviour and freezing the client - to prevent further packet flow -
// if applicable. GRANDPA client Misbehaviour consists of two headers at the same height both of which the light client
type Misbehaviour struct {
	ClientId uint64  `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty" yaml:"client_id"`
	Header1  *Header `protobuf:"bytes,2,opt,name=header_1,json=header1,proto3" json:"header_1,omitempty" yaml:"header_1"`
	Header2  *Header `protobuf:"bytes,3,opt,name=header_2,json=header2,proto3" json:"header_2,omitempty" yaml:"header_2"`
}

func (m *Misbehaviour) Reset()         { *m = Misbehaviour{} }
func (m *Misbehaviour) String() string { return proto.CompactTextString(m) }
func (*Misbehaviour) ProtoMessage()    {}
func (*Misbehaviour) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd16ccf01137b53b, []int{13}
}
func (m *Misbehaviour) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Misbehaviour) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Misbehaviour.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Misbehaviour) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Misbehaviour.Merge(m, src)
}
func (m *Misbehaviour) XXX_Size() int {
	return m.Size()
}
func (m *Misbehaviour) XXX_DiscardUnknown() {
	xxx_messageInfo_Misbehaviour.DiscardUnknown(m)
}

var xxx_messageInfo_Misbehaviour proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MmrRoot)(nil), "ibc.lightclients.grandpa.v1.MmrRoot")
	proto.RegisterType((*SignedCommitment)(nil), "ibc.lightclients.grandpa.v1.SignedCommitment")
	proto.RegisterType((*Commitment)(nil), "ibc.lightclients.grandpa.v1.Commitment")
	proto.RegisterType((*Signature)(nil), "ibc.lightclients.grandpa.v1.Signature")
	proto.RegisterType((*ValidatorMerkleProof)(nil), "ibc.lightclients.grandpa.v1.ValidatorMerkleProof")
	proto.RegisterType((*MmrLeaf)(nil), "ibc.lightclients.grandpa.v1.MmrLeaf")
	proto.RegisterType((*ParentNumberAndHash)(nil), "ibc.lightclients.grandpa.v1.ParentNumberAndHash")
	proto.RegisterType((*ValidatorSet)(nil), "ibc.lightclients.grandpa.v1.ValidatorSet")
	proto.RegisterType((*MmrLeafProof)(nil), "ibc.lightclients.grandpa.v1.MmrLeafProof")
	proto.RegisterType((*ClientState)(nil), "ibc.lightclients.grandpa.v1.ClientState")
	proto.RegisterType((*ConsensusState)(nil), "ibc.lightclients.grandpa.v1.ConsensusState")
	proto.RegisterType((*Header)(nil), "ibc.lightclients.grandpa.v1.Header")
	proto.RegisterType((*BlockHeader)(nil), "ibc.lightclients.grandpa.v1.BlockHeader")
	proto.RegisterType((*Misbehaviour)(nil), "ibc.lightclients.grandpa.v1.Misbehaviour")
}

func init() {
	proto.RegisterFile("ibc/lightclients/grandpa/v1/grandpa.proto", fileDescriptor_cd16ccf01137b53b)
}

var fileDescriptor_cd16ccf01137b53b = []byte{
	// 1243 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0xda, 0x6e, 0x1c, 0x3f, 0x6f, 0x1c, 0x77, 0x92, 0xa6, 0x6e, 0xab, 0x78, 0xc3, 0x14,
	0xda, 0x54, 0x22, 0x76, 0x6d, 0x38, 0x55, 0x42, 0x55, 0x37, 0x20, 0x25, 0x52, 0x53, 0xca, 0x04,
	0x21, 0xe0, 0xc0, 0x6a, 0xed, 0x1d, 0xdb, 0xab, 0x7a, 0x77, 0xac, 0xdd, 0xb1, 0x95, 0x20, 0x2e,
	0x1c, 0x10, 0x48, 0x20, 0xc4, 0x47, 0x40, 0x5c, 0x39, 0x23, 0x24, 0x24, 0xee, 0x3d, 0xf6, 0x08,
	0x17, 0xab, 0x4a, 0xbe, 0x81, 0x3f, 0x01, 0xda, 0x99, 0x59, 0x7b, 0xed, 0x18, 0xd3, 0xa8, 0xca,
	0x81, 0xdb, 0xcc, 0xfb, 0xf3, 0x9b, 0x79, 0xef, 0xfd, 0xde, 0xdb, 0x59, 0xb8, 0xe7, 0x36, 0x9a,
	0xd5, 0xae, 0xdb, 0xee, 0xf0, 0x66, 0xd7, 0xa5, 0x3e, 0x0f, 0xab, 0xed, 0xc0, 0xf6, 0x9d, 0x9e,
	0x5d, 0x1d, 0xd4, 0xe2, 0x65, 0xa5, 0x17, 0x30, 0xce, 0xd0, 0x2d, 0xb7, 0xd1, 0xac, 0x24, 0x4d,
	0x2b, 0xb1, 0x7e, 0x50, 0xbb, 0xb9, 0xd1, 0x66, 0x6d, 0x26, 0xec, 0xaa, 0xd1, 0x4a, 0xba, 0xe0,
	0xdf, 0x32, 0x90, 0x3d, 0xf4, 0x02, 0xc2, 0x18, 0x47, 0x1f, 0x81, 0xde, 0xe8, 0xb2, 0xe6, 0x33,
	0xab, 0x43, 0x6d, 0x87, 0x06, 0x25, 0x6d, 0x5b, 0xdb, 0xc9, 0xd7, 0x77, 0x2a, 0x0b, 0x50, 0x2b,
	0x66, 0xe4, 0xb0, 0x2f, 0xec, 0xcd, 0xcc, 0xf3, 0xa1, 0xb1, 0x44, 0xf2, 0x8d, 0x89, 0x08, 0x7d,
	0x05, 0x57, 0x43, 0xb7, 0xed, 0x53, 0xc7, 0x6a, 0x32, 0xcf, 0x73, 0xb9, 0x47, 0x7d, 0x5e, 0x4a,
	0x09, 0xdc, 0xdd, 0x85, 0xb8, 0x47, 0xc2, 0x6b, 0x6f, 0xec, 0x64, 0x6e, 0x47, 0xe0, 0xa3, 0xa1,
	0x51, 0x3a, 0xb1, 0xbd, 0xee, 0x03, 0x7c, 0x0e, 0x15, 0x93, 0x62, 0x38, 0xe3, 0x83, 0x7e, 0xd4,
	0x60, 0x73, 0x60, 0x77, 0x5d, 0xc7, 0xe6, 0x2c, 0xb0, 0x3c, 0x1a, 0x3c, 0xeb, 0x52, 0xab, 0x17,
	0x30, 0xd6, 0x2a, 0xa5, 0xc5, 0x1d, 0x6a, 0x0b, 0xef, 0xf0, 0x49, 0xec, 0x7a, 0x28, 0x3c, 0x9f,
	0x46, 0x8e, 0xe6, 0x5b, 0xea, 0x1e, 0x5b, 0xf2, 0x1e, 0xf3, 0xe1, 0x31, 0xd9, 0x18, 0xcc, 0x71,
	0x46, 0x9f, 0xc2, 0x8a, 0xe7, 0x05, 0x56, 0x97, 0xda, 0xad, 0x52, 0x46, 0xdc, 0xe0, 0xcd, 0x85,
	0x37, 0x38, 0xf4, 0x82, 0xc7, 0xd4, 0x6e, 0x99, 0xd7, 0xd5, 0xa1, 0x6b, 0xf2, 0xd0, 0x18, 0x03,
	0x93, 0xac, 0x27, 0x2d, 0x90, 0x0f, 0x85, 0x58, 0xaa, 0x22, 0xbc, 0x22, 0xf0, 0xef, 0xbd, 0x0a,
	0xbe, 0x8c, 0x6c, 0x4b, 0x1d, 0x72, 0x6d, 0xfa, 0x90, 0x38, 0x22, 0xdd, 0x4b, 0x18, 0xe3, 0xbf,
	0x35, 0x28, 0xce, 0xd6, 0x08, 0x35, 0x00, 0x12, 0x65, 0x96, 0xf4, 0xb9, 0xbb, 0xf0, 0x02, 0x89,
	0x02, 0xdf, 0x50, 0xc7, 0x5f, 0x95, 0xc7, 0x27, 0x2b, 0x9b, 0x40, 0x45, 0x36, 0x40, 0x54, 0x67,
	0x9b, 0xf7, 0x03, 0x1a, 0x96, 0x52, 0xdb, 0xe9, 0x9d, 0x7c, 0xfd, 0xce, 0x7f, 0x52, 0x49, 0x98,
	0xcf, 0x1e, 0x31, 0xc1, 0xc1, 0x24, 0x01, 0x8a, 0xff, 0xd4, 0x00, 0x12, 0x51, 0x3d, 0x88, 0xdb,
	0xc2, 0xef, 0x7b, 0x0d, 0xd5, 0x16, 0xab, 0xe6, 0xf5, 0xd1, 0xd0, 0x58, 0x97, 0x38, 0x49, 0x2d,
	0x56, 0xfc, 0x7f, 0x22, 0x76, 0xe8, 0x6d, 0xc8, 0xf6, 0xec, 0x93, 0x2e, 0xb3, 0x1d, 0xc1, 0x7a,
	0xdd, 0x44, 0xa3, 0xa1, 0x51, 0x90, 0x6e, 0x4a, 0x81, 0x49, 0x6c, 0x82, 0x3e, 0x80, 0xe2, 0x84,
	0x4f, 0x21, 0xe5, 0x96, 0xeb, 0x08, 0xa2, 0x66, 0xcc, 0x5b, 0xa3, 0xa1, 0x71, 0x7d, 0x96, 0x71,
	0xd2, 0x02, 0x93, 0xc2, 0x58, 0x74, 0x44, 0xf9, 0x81, 0x83, 0x1f, 0x42, 0x6e, 0x1c, 0x33, 0xaa,
	0x43, 0x6e, 0x1c, 0x9a, 0xb8, 0xba, 0x6e, 0x6e, 0x8c, 0x86, 0x46, 0x71, 0x26, 0x05, 0x98, 0x4c,
	0xcc, 0xf0, 0x4b, 0x0d, 0x36, 0xe6, 0x91, 0x1f, 0xdd, 0x81, 0x2b, 0x92, 0x5c, 0xda, 0x76, 0x7a,
	0x47, 0x37, 0x8b, 0xa3, 0xa1, 0xa1, 0xab, 0x60, 0x24, 0x49, 0xa4, 0x3a, 0x0a, 0x44, 0xa6, 0xc3,
	0x62, 0xad, 0x88, 0x44, 0x03, 0x51, 0xaa, 0x28, 0x6d, 0x89, 0x40, 0x66, 0x2d, 0x30, 0x29, 0x48,
	0xd1, 0x87, 0xad, 0xc7, 0x42, 0x80, 0xde, 0x05, 0x10, 0x0c, 0x74, 0x7d, 0x87, 0x1e, 0x8b, 0x4c,
	0xac, 0x9a, 0xd7, 0x26, 0xf5, 0x9b, 0xe8, 0x30, 0xc9, 0x45, 0x9b, 0x83, 0x68, 0x8d, 0x6e, 0x43,
	0x66, 0xdc, 0x60, 0xba, 0xb9, 0x36, 0x1a, 0x1a, 0xf9, 0x89, 0x3d, 0x26, 0x42, 0x89, 0xbf, 0x49,
	0x8b, 0xb9, 0x27, 0x7a, 0xa7, 0x04, 0xd9, 0x01, 0x0d, 0x42, 0x97, 0xf9, 0xb2, 0xb6, 0x24, 0xde,
	0xa2, 0x1f, 0x34, 0xd8, 0xec, 0xd9, 0x01, 0xf5, 0xb9, 0x2a, 0xaf, 0x65, 0xfb, 0x8e, 0xd5, 0xb1,
	0xc3, 0x8e, 0x1a, 0x62, 0xf7, 0x17, 0x32, 0xef, 0xa9, 0x70, 0x95, 0x54, 0x78, 0xe4, 0x3b, 0xfb,
	0x76, 0xd8, 0x99, 0x9d, 0x1f, 0xf3, 0xd1, 0x31, 0x59, 0xef, 0x9d, 0xf7, 0x45, 0xdf, 0x6b, 0x50,
	0x6a, 0x50, 0xda, 0x3a, 0xb1, 0x7c, 0x7a, 0xcc, 0x2d, 0xbb, 0xcf, 0x3b, 0x2c, 0x70, 0xf9, 0x49,
	0xc4, 0x04, 0x35, 0xd1, 0xee, 0xbd, 0xda, 0x44, 0x3b, 0xa2, 0xdc, 0xbc, 0xab, 0x6e, 0x62, 0x28,
	0x16, 0xff, 0x0b, 0x30, 0x26, 0xd7, 0x84, 0xea, 0x09, 0x3d, 0xe6, 0x8f, 0x62, 0xc5, 0x11, 0xe5,
	0x68, 0x0f, 0xd6, 0x7a, 0x76, 0x60, 0x37, 0x3b, 0xb6, 0xeb, 0x8b, 0x4f, 0x46, 0xa8, 0x52, 0x7e,
	0x73, 0x34, 0x34, 0x36, 0xc7, 0xe1, 0x25, 0x0d, 0x30, 0x29, 0x8c, 0x25, 0xfb, 0x42, 0xf0, 0xb5,
	0x06, 0xeb, 0x73, 0xd2, 0xf4, 0x5a, 0x4d, 0x57, 0x91, 0x53, 0x36, 0x60, 0x8c, 0xab, 0xae, 0x5b,
	0x9f, 0x9e, 0x9d, 0x91, 0x46, 0xce, 0xce, 0xe8, 0xbb, 0x87, 0xdf, 0x07, 0x3d, 0x99, 0x18, 0x54,
	0x80, 0x94, 0xeb, 0x88, 0x13, 0x33, 0x24, 0xe5, 0x3a, 0xa8, 0x08, 0xe9, 0x2e, 0xf5, 0x25, 0x81,
	0x49, 0xb4, 0x44, 0x08, 0x32, 0x02, 0x3d, 0xca, 0xb9, 0x4e, 0xc4, 0x1a, 0x73, 0xd0, 0x93, 0xe3,
	0x14, 0x6d, 0x4d, 0x91, 0x57, 0xa2, 0x25, 0x58, 0x1a, 0xab, 0x9b, 0xac, 0xaf, 0x3e, 0x89, 0x4a,
	0xbd, 0x17, 0x09, 0xa2, 0x4e, 0x73, 0x39, 0xf5, 0xc2, 0x52, 0x7a, 0xb6, 0xd3, 0x84, 0x18, 0x13,
	0xa9, 0xc6, 0xbf, 0xa4, 0x21, 0xbf, 0x27, 0x0a, 0x7d, 0xc4, 0x6d, 0x4e, 0xd1, 0x0d, 0x58, 0x91,
	0xf9, 0x56, 0x11, 0xe4, 0x48, 0x56, 0xec, 0x0f, 0x9c, 0x73, 0x29, 0x4d, 0x5d, 0x20, 0xa5, 0xef,
	0xc1, 0x6a, 0x2b, 0x60, 0x5f, 0xd2, 0xa8, 0x8e, 0x11, 0xb7, 0x54, 0x33, 0x96, 0x46, 0x43, 0x63,
	0x43, 0x3a, 0x4f, 0xa9, 0x31, 0xd1, 0xe5, 0x7e, 0x5f, 0x6c, 0xcf, 0xbd, 0x2c, 0x32, 0xaf, 0xff,
	0xb2, 0xf8, 0x18, 0xae, 0x76, 0x6d, 0x4e, 0x43, 0x9e, 0x7c, 0x59, 0x5c, 0xb9, 0xd0, 0x27, 0x87,
	0x14, 0x25, 0x42, 0x62, 0xd6, 0x3f, 0x81, 0xd5, 0xa9, 0xf9, 0x5a, 0x5a, 0xbe, 0x60, 0x57, 0x11,
	0x3d, 0x39, 0x8c, 0x1f, 0x64, 0xbe, 0xfb, 0xd9, 0x58, 0xc2, 0x7f, 0x68, 0x50, 0xd8, 0x63, 0x7e,
	0x48, 0xfd, 0xb0, 0x1f, 0xca, 0x3a, 0x19, 0x90, 0x57, 0xad, 0x2f, 0xa6, 0x89, 0x18, 0xcc, 0x04,
	0xa4, 0x48, 0x34, 0xc0, 0x1b, 0xf3, 0xaa, 0x35, 0x5d, 0x94, 0x2d, 0x80, 0x30, 0x02, 0xb3, 0x12,
	0x5c, 0xcc, 0x09, 0x89, 0x78, 0xce, 0xdd, 0x85, 0x35, 0x7a, 0xcc, 0x03, 0xd7, 0x0f, 0xdd, 0x66,
	0x28, 0x6d, 0x44, 0x7f, 0x92, 0xc2, 0x44, 0x2c, 0x0c, 0x37, 0x61, 0xd9, 0x71, 0xdb, 0x34, 0x94,
	0xf9, 0xd3, 0x89, 0xda, 0xa9, 0xcb, 0xff, 0x9a, 0x82, 0x65, 0x95, 0xf3, 0x4b, 0x78, 0x20, 0x26,
	0x5f, 0x44, 0xa9, 0x4b, 0x7e, 0x11, 0xa5, 0x2f, 0xf3, 0x45, 0xa4, 0xb2, 0xf5, 0xbb, 0x06, 0xf9,
	0x44, 0xc8, 0xff, 0xa3, 0x3a, 0x7f, 0x9b, 0x02, 0xfd, 0xd0, 0x0d, 0x1b, 0xb4, 0x63, 0x0f, 0x5c,
	0xd6, 0x0f, 0x50, 0x0d, 0x72, 0x32, 0x41, 0xf1, 0x2c, 0xc9, 0x24, 0x5f, 0x0e, 0x63, 0x15, 0x26,
	0x2b, 0x72, 0x7d, 0xe0, 0xa0, 0x2f, 0x60, 0x45, 0x52, 0xc3, 0xaa, 0xa9, 0x6a, 0xde, 0x5e, 0x98,
	0x6d, 0xc5, 0x8b, 0xf2, 0xe9, 0xd0, 0xc8, 0xca, 0x75, 0x6d, 0x52, 0xd3, 0x18, 0x09, 0x93, 0xac,
	0x5c, 0xd6, 0x12, 0xf8, 0x75, 0x55, 0xcd, 0x8b, 0xe2, 0xd7, 0xcf, 0xe1, 0xd7, 0xc7, 0xf8, 0x75,
	0x99, 0x09, 0xf3, 0xb3, 0xe7, 0xa7, 0x65, 0xed, 0xc5, 0x69, 0x59, 0x7b, 0x79, 0x5a, 0xd6, 0x7e,
	0x3a, 0x2b, 0x2f, 0xbd, 0x38, 0x2b, 0x2f, 0xfd, 0x75, 0x56, 0x5e, 0xfa, 0xfc, 0x61, 0xdb, 0xe5,
	0x9d, 0x7e, 0xa3, 0xd2, 0x64, 0x5e, 0xb5, 0xc9, 0x42, 0x8f, 0x85, 0x55, 0xb7, 0xd1, 0xdc, 0x6d,
	0xb3, 0xaa, 0xc7, 0x9c, 0x7e, 0x97, 0x86, 0xf2, 0x47, 0x6d, 0x37, 0xfe, 0x53, 0xab, 0xdd, 0xdf,
	0x8d, 0x7f, 0xd6, 0xf8, 0x49, 0x8f, 0x86, 0x8d, 0x65, 0xf1, 0xd7, 0xf5, 0xce, 0x3f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x82, 0xd8, 0x67, 0x8e, 0xd5, 0x0d, 0x00, 0x00,
}

func (m *MmrRoot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MmrRoot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MmrRoot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MmrLeafProof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.MmrLeaf.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.ValidatorMerkleProof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.SignedCommitment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.BlockHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SignedCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGrandpa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Commitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Commitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidatorSetId != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.ValidatorSetId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.BlockNumber != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorMerkleProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorMerkleProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorMerkleProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Leaf) > 0 {
		i -= len(m.Leaf)
		copy(dAtA[i:], m.Leaf)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Leaf)))
		i--
		dAtA[i] = 0x22
	}
	if m.LeafIndex != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.LeafIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.NumberOfLeaves != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.NumberOfLeaves))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Proof) > 0 {
		for iNdEx := len(m.Proof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Proof[iNdEx])
			copy(dAtA[i:], m.Proof[iNdEx])
			i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Proof[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MmrLeaf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MmrLeaf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MmrLeaf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParachainHeads) > 0 {
		i -= len(m.ParachainHeads)
		copy(dAtA[i:], m.ParachainHeads)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ParachainHeads)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.BeefyNextAuthoritySet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ParentNumberAndHash.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Version != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ParentNumberAndHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParentNumberAndHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParentNumberAndHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MmrRoot) > 0 {
		i -= len(m.MmrRoot)
		copy(dAtA[i:], m.MmrRoot)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.MmrRoot)))
		i--
		dAtA[i] = 0x12
	}
	if m.BlockNumber != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Len != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MmrLeafProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MmrLeafProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MmrLeafProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Items[iNdEx])
			copy(dAtA[i:], m.Items[iNdEx])
			i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Items[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.LeafCount != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.LeafCount))
		i--
		dAtA[i] = 0x10
	}
	if m.LeafIndex != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.LeafIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidatorSet != nil {
		{
			size, err := m.ValidatorSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrandpa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.LatestCommitment != nil {
		{
			size, err := m.LatestCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrandpa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.BlockHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.FrozenHeight != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.FrozenHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockNumber != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Digest) > 0 {
		i -= len(m.Digest)
		copy(dAtA[i:], m.Digest)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Digest)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExtrinsicsRoot) > 0 {
		i -= len(m.ExtrinsicsRoot)
		copy(dAtA[i:], m.ExtrinsicsRoot)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ExtrinsicsRoot)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StateRoot) > 0 {
		i -= len(m.StateRoot)
		copy(dAtA[i:], m.StateRoot)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.StateRoot)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockNumber != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ParentHash) > 0 {
		i -= len(m.ParentHash)
		copy(dAtA[i:], m.ParentHash)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ParentHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MmrLeafProof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.MmrLeaf.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.BlockHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGrandpa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BlockHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Digest) > 0 {
		i -= len(m.Digest)
		copy(dAtA[i:], m.Digest)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.Digest)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExtrinsicsRoot) > 0 {
		i -= len(m.ExtrinsicsRoot)
		copy(dAtA[i:], m.ExtrinsicsRoot)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ExtrinsicsRoot)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StateRoot) > 0 {
		i -= len(m.StateRoot)
		copy(dAtA[i:], m.StateRoot)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.StateRoot)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockNumber != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ParentHash) > 0 {
		i -= len(m.ParentHash)
		copy(dAtA[i:], m.ParentHash)
		i = encodeVarintGrandpa(dAtA, i, uint64(len(m.ParentHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Misbehaviour) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Misbehaviour) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Misbehaviour) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Header2 != nil {
		{
			size, err := m.Header2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrandpa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Header1 != nil {
		{
			size, err := m.Header1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGrandpa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ClientId != 0 {
		i = encodeVarintGrandpa(dAtA, i, uint64(m.ClientId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGrandpa(dAtA []byte, offset int, v uint64) int {
	offset -= sovGrandpa(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MmrRoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BlockHeader.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.SignedCommitment.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.ValidatorMerkleProof.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.MmrLeaf.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.MmrLeafProof.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	return n
}

func (m *SignedCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Commitment.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	return n
}

func (m *Commitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNumber != 0 {
		n += 1 + sovGrandpa(uint64(m.BlockNumber))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.ValidatorSetId != 0 {
		n += 1 + sovGrandpa(uint64(m.ValidatorSetId))
	}
	return n
}

func (m *Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *ValidatorMerkleProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Proof) > 0 {
		for _, b := range m.Proof {
			l = len(b)
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	if m.NumberOfLeaves != 0 {
		n += 1 + sovGrandpa(uint64(m.NumberOfLeaves))
	}
	if m.LeafIndex != 0 {
		n += 1 + sovGrandpa(uint64(m.LeafIndex))
	}
	l = len(m.Leaf)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *MmrLeaf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovGrandpa(uint64(m.Version))
	}
	l = m.ParentNumberAndHash.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.BeefyNextAuthoritySet.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = len(m.ParachainHeads)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *ParentNumberAndHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNumber != 0 {
		n += 1 + sovGrandpa(uint64(m.BlockNumber))
	}
	l = len(m.MmrRoot)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *ValidatorSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGrandpa(uint64(m.Id))
	}
	if m.Len != 0 {
		n += 1 + sovGrandpa(uint64(m.Len))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *MmrLeafProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeafIndex != 0 {
		n += 1 + sovGrandpa(uint64(m.LeafIndex))
	}
	if m.LeafCount != 0 {
		n += 1 + sovGrandpa(uint64(m.LeafCount))
	}
	if len(m.Items) > 0 {
		for _, b := range m.Items {
			l = len(b)
			n += 1 + l + sovGrandpa(uint64(l))
		}
	}
	return n
}

func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovGrandpa(uint64(m.BlockNumber))
	}
	if m.FrozenHeight != 0 {
		n += 1 + sovGrandpa(uint64(m.FrozenHeight))
	}
	l = m.BlockHeader.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	if m.LatestCommitment != nil {
		l = m.LatestCommitment.Size()
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.ValidatorSet != nil {
		l = m.ValidatorSet.Size()
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovGrandpa(uint64(m.BlockNumber))
	}
	l = len(m.StateRoot)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = len(m.ExtrinsicsRoot)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BlockHeader.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.MmrLeaf.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	l = m.MmrLeafProof.Size()
	n += 1 + l + sovGrandpa(uint64(l))
	return n
}

func (m *BlockHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovGrandpa(uint64(m.BlockNumber))
	}
	l = len(m.StateRoot)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = len(m.ExtrinsicsRoot)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func (m *Misbehaviour) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientId != 0 {
		n += 1 + sovGrandpa(uint64(m.ClientId))
	}
	if m.Header1 != nil {
		l = m.Header1.Size()
		n += 1 + l + sovGrandpa(uint64(l))
	}
	if m.Header2 != nil {
		l = m.Header2.Size()
		n += 1 + l + sovGrandpa(uint64(l))
	}
	return n
}

func sovGrandpa(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGrandpa(x uint64) (n int) {
	return sovGrandpa(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MmrRoot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MmrRoot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MmrRoot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SignedCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorMerkleProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValidatorMerkleProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrLeaf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MmrLeaf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrLeafProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MmrLeafProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSetId", wireType)
			}
			m.ValidatorSetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorSetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorMerkleProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorMerkleProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorMerkleProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = append(m.Proof, make([]byte, postIndex-iNdEx))
			copy(m.Proof[len(m.Proof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfLeaves", wireType)
			}
			m.NumberOfLeaves = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfLeaves |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafIndex", wireType)
			}
			m.LeafIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leaf = append(m.Leaf[:0], dAtA[iNdEx:postIndex]...)
			if m.Leaf == nil {
				m.Leaf = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MmrLeaf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MmrLeaf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MmrLeaf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentNumberAndHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ParentNumberAndHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeefyNextAuthoritySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BeefyNextAuthoritySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeads", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParachainHeads = append(m.ParachainHeads[:0], dAtA[iNdEx:postIndex]...)
			if m.ParachainHeads == nil {
				m.ParachainHeads = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParentNumberAndHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParentNumberAndHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParentNumberAndHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmrRoot = append(m.MmrRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.MmrRoot == nil {
				m.MmrRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MmrLeafProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MmrLeafProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MmrLeafProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafIndex", wireType)
			}
			m.LeafIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafCount", wireType)
			}
			m.LeafCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, make([]byte, postIndex-iNdEx))
			copy(m.Items[len(m.Items)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenHeight", wireType)
			}
			m.FrozenHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrozenHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LatestCommitment == nil {
				m.LatestCommitment = &Commitment{}
			}
			if err := m.LatestCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorSet == nil {
				m.ValidatorSet = &ValidatorSet{}
			}
			if err := m.ValidatorSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = append(m.ParentHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentHash == nil {
				m.ParentHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateRoot = append(m.StateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.StateRoot == nil {
				m.StateRoot = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtrinsicsRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtrinsicsRoot = append(m.ExtrinsicsRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtrinsicsRoot == nil {
				m.ExtrinsicsRoot = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrLeaf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MmrLeaf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrLeafProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MmrLeafProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = append(m.ParentHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentHash == nil {
				m.ParentHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateRoot = append(m.StateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.StateRoot == nil {
				m.StateRoot = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtrinsicsRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtrinsicsRoot = append(m.ExtrinsicsRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtrinsicsRoot == nil {
				m.ExtrinsicsRoot = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Misbehaviour) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Misbehaviour: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Misbehaviour: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			m.ClientId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header1 == nil {
				m.Header1 = &Header{}
			}
			if err := m.Header1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGrandpa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGrandpa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header2 == nil {
				m.Header2 = &Header{}
			}
			if err := m.Header2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGrandpa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGrandpa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGrandpa(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGrandpa
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGrandpa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGrandpa
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGrandpa
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGrandpa
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGrandpa        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGrandpa          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGrandpa = fmt.Errorf("proto: unexpected end of group")
)
